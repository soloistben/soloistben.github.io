<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>MR.C</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-23T08:10:37.491Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>(soloistben)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>algorithm</title>
    <link href="http://yoursite.com/2019/11/14/algorithm/"/>
    <id>http://yoursite.com/2019/11/14/algorithm/</id>
    <published>2019-11-14T12:44:27.000Z</published>
    <updated>2019-11-23T08:10:37.491Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LCS-Longest-Common-Subsequence"><a href="#LCS-Longest-Common-Subsequence" class="headerlink" title="LCS Longest Common Subsequence"></a>LCS Longest Common Subsequence</h4><ul><li>运用动态规划方法查找给定两个序列的最大公共子序列（子序列之间的字符可以不连续，若子串substring的字符必须连续）</li><li>由序列尾部开始：<ul><li>若两个序列尾部字符相等：LCS[i][j] = LSC[i-1][j-1] +1 </li><li>若两个序列尾部字符不相等：LCS[i][j] = max(LSC[i-1][j], LSC[i][j-1])</li></ul></li></ul><p><img src="https://github.com/soloistben/images/raw/master/algorithm_image/lcs.png" alt="LCS"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">str1 = <span class="string">'GXTXAYB'</span></span><br><span class="line">str2 = <span class="string">'AGGTAB'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    L = np.zeros((len(str1)+<span class="number">1</span>, len(str2)+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#print(L)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>:</span><br><span class="line">                L[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]:</span><br><span class="line">                L[i][j] = L[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L[i][j] = max(L[i<span class="number">-1</span>][j], L[i][j<span class="number">-1</span>])</span><br><span class="line">    print(L)</span><br><span class="line">    <span class="keyword">return</span> L[<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">print(lcs(str1, str2))</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0. 0. 0. 0. 0. 0. 0.]</span><br><span class="line"> [0. 0. 1. 1. 1. 1. 1.]</span><br><span class="line"> [0. 0. 1. 1. 1. 1. 1.]</span><br><span class="line"> [0. 0. 1. 1. 2. 2. 2.]</span><br><span class="line"> [0. 0. 1. 1. 2. 2. 2.]</span><br><span class="line"> [0. 1. 1. 1. 2. 3. 3.]</span><br><span class="line"> [0. 1. 1. 1. 2. 3. 3.]</span><br><span class="line"> [0. 1. 1. 1. 2. 3. 4.]]</span><br><span class="line">4.0</span><br></pre></td></tr></table></figure><p><img src="https://github.com/soloistben/images/raw/master/algorithm_image/dynamic_lcs.png" alt="dynamic_lcs"></p><h6 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">Algorithm: LCS(A, B)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">L[<span class="number">0.</span>..|A|][<span class="number">0.</span>..|B|]</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to |A|+<span class="number">1</span> do</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">0</span> to |B|+<span class="number">1</span> do </span><br><span class="line">        <span class="keyword">if</span> A[i<span class="number">-1</span>]=B[j<span class="number">-1</span>] then L[i][j]=L[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span> L[i][j]=max(L[i<span class="number">-1</span>][j], L[i][j<span class="number">-1</span>])</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> L</span><br><span class="line">----------------------------------------------------</span><br><span class="line">O(nm)</span><br></pre></td></tr></table></figure><hr><h4 id="SA-Sequence-Alignment"><a href="#SA-Sequence-Alignment" class="headerlink" title="SA Sequence Alignment"></a>SA Sequence Alignment</h4><ul><li>运用动态规划方法对给定两个序列做对比（原用于基因DNA链碱基的序列对比）</li><li>对比结果有三种情况：<ul><li>match 相等</li><li>unmatch 不想等</li><li>gap 缺额（两个序列长度不一致）</li></ul></li><li>使用打分原则（match不扣分，unmatch和gap扣不同的分数）</li></ul><p>eg.<br>    A G C T<br>    A U T<br>[第一A和最后T属于match，第二或第三U属于unmatch，第三或第二属于gap]<br>[若match不扣分，unmatch扣3分，gap扣2分，则本次对比=5分，扣分（惩罚分）越低越好]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">str1 = <span class="string">'AGGGCT'</span></span><br><span class="line">str2 = <span class="string">'SAGE'</span></span><br><span class="line">p_unmatch = <span class="number">3</span></span><br><span class="line">p_gap = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SA</span><span class="params">(str1, str2, p_unmatch, p_gap)</span>:</span></span><br><span class="line">    P = np.zeros((len(str1)+<span class="number">1</span>, len(str2)+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>:</span><br><span class="line">                P[i][<span class="number">0</span>] = i*p_gap</span><br><span class="line">                P[<span class="number">0</span>][j] = j*p_gap</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(str1)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(str2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]:</span><br><span class="line">                P[i][j] = P[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i][j] = min(&#123;P[i<span class="number">-1</span>][j<span class="number">-1</span>]+p_unmatch, P[i<span class="number">-1</span>][j]+p_gap, P[i][j<span class="number">-1</span>]+p_gap&#125;)</span><br><span class="line">            </span><br><span class="line">    print(P)</span><br><span class="line">    <span class="keyword">return</span> P[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">print(SA(str1, str2, p_unmatch, p_gap))</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[ 0.  2.  4.  6.  8.]</span><br><span class="line"> [ 2.  3.  2.  4.  6.]</span><br><span class="line"> [ 4.  5.  4.  2.  4.]</span><br><span class="line"> [ 6.  7.  6.  4.  5.]</span><br><span class="line"> [ 8.  9.  8.  6.  7.]</span><br><span class="line"> [10. 11. 10.  8.  9.]</span><br><span class="line"> [12. 13. 12. 10. 11.]]</span><br><span class="line">11.0</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">Algorithm: SA(A, B, p_gap, p_xy)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">P[<span class="number">0.</span>..|A|][<span class="number">0.</span>..|B|]</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to |A|+<span class="number">1</span> do</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">0</span> to |B|+<span class="number">1</span> do </span><br><span class="line">        P[i][<span class="number">0</span>] = i*p_gap</span><br><span class="line">        P[<span class="number">0</span>][j] = j*p_gap</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to |A|+<span class="number">1</span> do</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">0</span> to |B|+<span class="number">1</span> do </span><br><span class="line">        <span class="keyword">if</span> A[i<span class="number">-1</span>]=B[j<span class="number">-1</span>] then P[i][j]=P[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">        <span class="keyword">else</span> P[i][j]=min(P[i<span class="number">-1</span>][j<span class="number">-1</span>]+p_xy, P[i<span class="number">-1</span>][j]+p_gap, P[i][j<span class="number">-1</span>]+p_gap)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> P</span><br><span class="line">----------------------------------------------------</span><br><span class="line">O(nm)</span><br></pre></td></tr></table></figure><hr><h4 id="set-cover-problem"><a href="#set-cover-problem" class="headerlink" title="set cover problem"></a>set cover problem</h4><ul><li>给定一个集合B，和一些子集sets，在子集中找到最好的覆盖原集合的子集（贪心算法）</li><li>在t时刻，选择子集设为St，当前还剩集合元素个数为nt，以选子集的元素集合为P</li><li>则在子集中，每次选择与原集合<strong>相交</strong>最多元素的子集，且符合公式|St|&gt;= nt/|P|</li></ul><h5 id="S-0-1-2-3-4-5-6-7-8-9"><a href="#S-0-1-2-3-4-5-6-7-8-9" class="headerlink" title="S = {0,1,2,3,4,5,6,7,8,9}"></a>S = {0,1,2,3,4,5,6,7,8,9}</h5><h5 id="Sets-0-1-2-3-1-4-2-2-3-5-1-7-4-6-3-6-8-7-9"><a href="#Sets-0-1-2-3-1-4-2-2-3-5-1-7-4-6-3-6-8-7-9" class="headerlink" title="Sets = {0,1}, {2,3}, {1,4,2}, {2,3,5}, {1,7}, {4,6}, {3,6,8}, {7,9}"></a>Sets = {0,1}, {2,3}, {1,4,2}, {2,3,5}, {1,7}, {4,6}, {3,6,8}, {7,9}</h5><p>Let nt be the number of uncovered elements after step t, P be optimal selection<br>Choose max (sets ∩ S) in each step:</p><ul><li>Step 1: n1 = 10, S1 = {1,4,2}, P = S1 = {1,2,4}</li><li>Step 2: n2 = 7, S2 = {3,6,8}, P = S1US2 = {1,2,3,4,6,8}</li><li>Step 3: n3 = 4, S3 = {7,9}, P = S1US2US3 = {1,2,3,4,6,7,8,9}</li><li>Step 4: n4 = 2, S4 = {0,1}, P = S1US2US3Us4 = {0,1,2,3,4,6,7,8,9}</li><li>Step 5: n5 = 1, S5 = {2,3,5}, P = S1US2US3US4US5 = {0,1,2,3,4,5,6,7,8,9} = S</li></ul><h5 id="so-cover-1-4-2-U-3-6-8-U-7-9-U-0-1-U-2-3-5-S"><a href="#so-cover-1-4-2-U-3-6-8-U-7-9-U-0-1-U-2-3-5-S" class="headerlink" title="so cover {1,4,2}U{3,6,8}U{7,9}U{0,1}U{2,3,5} = S"></a>so cover {1,4,2}U{3,6,8}U{7,9}U{0,1}U{2,3,5} = S</h5><p>set cover problem need to obey |St| ≥ nt/|P| </p><ul><li>if choose l S1| = 2 in step 1, n2 = 8, and n2/|P| = 8/2 = 4, so we need to choose a set containing 4 elements in step 2. That is contradictory.</li><li>if choose l S1| = 3 in step 1, n2 = 7, and n2/|P| = 7/3 ≈ 3, so we need to choose a set containing 3 elements in step 2. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LCS-Longest-Common-Subsequence&quot;&gt;&lt;a href=&quot;#LCS-Longest-Common-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;LCS Longest Common Subsequence&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GNN</title>
    <link href="http://yoursite.com/2019/08/19/GNN/"/>
    <id>http://yoursite.com/2019/08/19/GNN/</id>
    <published>2019-08-19T05:39:28.000Z</published>
    <updated>2019-08-20T01:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NOTE-of-Graph-Neural-Networks-A-Review-of-Methods-and-Applications"><a href="#NOTE-of-Graph-Neural-Networks-A-Review-of-Methods-and-Applications" class="headerlink" title="NOTE of Graph Neural Networks: A Review of Methods and Applications"></a>NOTE of Graph Neural Networks: A Review of Methods and Applications</h4><ol><li>As a unique non-Euclidean data structure for machine learning, graph analysis focuses on node classification, link prediction, and clustering.</li><li>Why GNN?</li></ol><ul><li>Composed to CNN, GNN is highly expressive representations</li><li>shared weights reduce the computational cost compared with traditional spectral graph theory; multi-layer structure is the key to deal with hierarchical patterns, which captures the features of various sizes.</li><li>CNN can only operate on regular Euclidean data like images (2D grid) and text (1D sequence), GNN can.</li><li>graph embedding learns to represent graph nodes, edges or sub-graphs in low-dimensional vectors. </li><li>Deep-Walk, which is first graph embedding, is based on representation learning, word embedding and Skip-Gram model. Just like node2vec. However, <ul><li>no parameters are shared between nodes, so it means the number of parameters grows linearly with the number of nodes. </li><li>The direct embedding methods lack the ability of generalization, which means they cannot deal with dynamic graphs or generalize to new graphs</li></ul></li></ul><ol start="3"><li>GNN model input and/or output consisting of elements and their dependency.</li><li>There isn’t a natural order of nodes in the graph. (CNN &amp; RNN can’t input node of no special order)</li><li>In the standard neural networks, the dependency information is just regarded as the feature of nodes, not edge which represents the information of dependency between two nodes in a graph!</li><li>GNN update the hidden state of nodes by a weighted sum of the states of their neighborhood.</li><li>Human brain is almost based on the graph which is extracted from daily experience. </li><li>GNN can learn the <em>reasoning</em> graph from large experimental data.</li><li><strong>Message Passing Neural Network (MPNN)</strong> could generalize several graph neural network and graph convolutional network approaches. </li><li><strong>Non-local Neural Network (NLNN)</strong> unifies several “self-attention”-style methods.</li><li>Both of MPNN&amp;NLNN focus on specific application domains and can’t provide a review over other graph attention models.</li><li><strong>Graph Network (GN) </strong>has strong capability to generalize other models. However, the graph network model is highly abstract and only gives a rough classification of the applications.</li><li>Graph neural networks suffer from over-smoothing and scaling problems. There are still no effective methods for dealing with dynamic graphs as well as modeling non-structural sensory data.</li><li>Original framework:</li></ol><ul><li>Notations<br><img src="https://github.com/soloistben/images/raw/master/gnn_image/1.jpg" alt="chinese"><br><img src="https://github.com/soloistben/images/raw/master/gnn_image/2.png" alt="eng"></li><li>The target of GNN is to learn a state embedding <strong>h_v ∈ Rs </strong>which contains the information of neighborhood for each node.</li><li>Let <strong>f</strong> be a parametric function, called local transition function, that is shared among all nodes and updates the node state according to the input neighborhood.</li><li>Let <strong>g</strong> be the local output function that describes how the output is produced.</li><li><strong>h_v = f (x_v, x_co[v], h_ne[v], x_ne[v])  o_v = g (h_v, x_v)</strong>  (x is the features of v)</li><li><strong>Vectorize: H = F (H, X)  O = G (H, XN)</strong>  (F is global translation function, G is global output function)</li><li>The value of H is the fixed point of Eq.3 and is uniquely defined with the assumption that F is a contraction map.</li><li>GNN uses the following classic iterative scheme for computing the state.     <strong>Ht+1 = F(Ht, X)</strong></li><li>With the target information (t_v for a specific node) for the supervision. <strong>loss = ⅀ (t_i − o_i)</strong></li></ul><ol start="15"><li>Limitations:</li></ol><ul><li>GNN is inefficient to update the hidden states of nodes iteratively for the fixed point.</li><li>There are also some informative features on the edges which cannot be effectively modeled in the original GNN. </li><li>It’s unsuitable to use the fixed points if we focus on the representation of nodes instead of graphs because the distribution of representation in the fixed point will be much smooth in value and less informative for distinguishing each node.</li></ul><ol start="16"><li><strong>Variants of Graph Neural Networks</strong> to release the limitations:</li></ol><ul><li>different graph types:<ul><li>Directed Graphs. Directed edges can bring more information than undirected edges.</li><li>Heterogeneous Graphs. <ul><li>The simplest way to process heterogeneous graph is to convert the type of each node to a one-hot feature vector which is concatenated with the original feature.</li><li>For each neighbor group, GraphInception treats it as a sub-graph in a homogeneous graph to do propagation and concatenates the propagation results from different homogeneous graphs to do a collective node representation. (heterogeneous graph attention network, <strong>HAN</strong>)</li><li>[<a href="https://zhuanlan.zhihu.com/p/47040007]" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47040007]</a></li></ul></li><li>Graphs with Edge Information.<ul><li>Converting the graph to a bipartite graph where the original edges also become nodes and one original edge is split into two new edges which means there are two new edges between the edge node and begin/end nodes. (The encoder of <strong>G2S</strong> uses the following aggregation function for neighbors).</li><li>Adapting different weight matrices for the propagation on different kinds of edges. When the number of relations is very large, r-GCN introduces two kinds of regularization to reduce the number of parameters for modeling amounts of relations: basis and block diagonal-decomposition</li></ul></li><li>Dynamic Graphs. It has static graph structure and dynamic input signals.</li></ul></li><li>several modifications:<ul><li><strong>Graph Convolutional Network (GCN)</strong>: convolutions to the graph domain<ul><li>spectral approaches,使用谱分解的方法，应用图的拉普拉斯矩阵分解进行节点的信息收集     </li><li>non-spectral (spatial) approaches,直接使用图的拓扑结构，根据图的邻居信息进行信息收集</li></ul></li><li><strong>Gated graph neural network (GGNN)</strong>: using the gate mechanism like GRU or LSTM in the propagation step to diminish the restrictions in the former GNN models and improve the long-term propagation of information across the graph structure. Tree LSTM、Graph LSTM and Sentence LSTM</li><li><strong>Graph Attention Network (GAT)</strong> : incorporates the attention mechanism into the propagation step. <ul><li>GAT computes the hidden states of each node by attending over its neighbors, following a self-attention strategy.     </li><li>Gated Attention Network (GAAN) also uses the multi-head attention mechanism. However, it uses a self-attention mechanism to gather information from different heads to replace the average operation of GAT.</li></ul></li><li><strong>Residual connection</strong>: aiming to achieve better results as more layers make each node aggregate more information from neighbors, because more layers could also propagate the noisy information from an exponentially increasing number of expanded neighborhood members.<ul><li>Highway GCN</li><li>Jump Knowledge Network, selects from all of the intermediate representations (which ”jump” to the last layer) for each node at the last layer, which makes the model adapt the effective neighborhood size for each node as needed. uses three approaches of concatenation, max-pooling and LSTM-attention in the experiments to aggregate information. (The Jump Knowledge Network performs well on the experiments in social, bioinformatics and citation networks. It could also be combined with models like Graph Convolutional Networks, GraphSAGE and Graph Attention Networks to improve their performance.)</li></ul></li><li><strong>Hierarchical Pooling</strong>, Complicated and large-scale graphs usually carry rich hierarchical structures which are of great importance for node-level and graph-level classification tasks</li></ul></li></ul><ol start="17"><li>Training Method:</li></ol><ul><li>Sampling<ul><li>GraphSAGE replaced full graph Laplacian in GCN with learnable aggregation functions, which are key to perform message passing and generalize to unseen nodes.  With learned aggregation and propagation functions, GraphSAGE could generate embeddings for unseen nodes.</li><li>PinSage, By simulating random walks starting from target nodes, this approach chooses the top T nodes with the highest normalized visit counts.</li><li>FastGCN, Instead of sampling neighbors for each node, FastGCN directly samples the receptive field for each layer.  </li><li>adaptive sampler could find optimal sampling importance and reduce variance simultaneously</li></ul></li><li>Receptive Field Control, a control-variate based stochastic approximation algorithms for GCN by utilizing the historical activations of nodes as a control variate. </li><li>Data Augmentation, To solve the limitations, the authors proposed Co-Training GCN and Self-Training GCN to enlarge the training dataset. </li><li>Unsupervised Training, Graph auto-encoders (GAE) aim at representing nodes into low-dimensional vectors by an unsupervised training manner.</li></ul><ol start="18"><li>Frameworks:</li></ol><ul><li><strong>Message Passing Neural Networks (MPNN)</strong> unified GNN &amp; GCN. It abstracts the commonalities between several of the most popular models for graph-structured data.<ul><li>message passing </li><li>Readout computes a feature vector for the whole graph</li></ul></li><li><strong>Non-local Neural Networks (NLNN)</strong> unified several self-attention for capturing long-range dependencies with deep neural networks. It computes the response at a position as a weighted sum of the features at all positions. List the choices for f function:<ul><li>Gaussian (natural choice) </li><li>Embedded Gaussian </li><li>Dot product </li><li>Concatenation.</li></ul></li><li><span style="border-bottom:2px dashed red;"><strong>Graph Networks (GN) </strong>unified MPNN &amp; NLNN and so on.</span><ul><li>Graph definition</li><li>GN block contains<ul><li>three “update” functions, φ_e, φ_h &amp; φ_u, </li><li>three “aggregation” functions, ρ ( The ρ functions must be invariant to permutations of their inputs and should take variable numbers of arguments)<br><img src="https://github.com/soloistben/images/raw/master/gnn_image/3.png" alt="func"></li></ul></li><li>Computation steps<br><img src="https://github.com/soloistben/images/raw/master/gnn_image/4.png" alt="steps"></li><li>Design Principles<ul><li><strong>Flexible representations</strong><ul><li>One can simply tailor the output of a GN block according to specific demands of tasks </li><li>be applied to both structural scenarios where the graph structure is explicit and non structural scenarios where the relational structure should be inferred or assumed.</li></ul></li><li><strong>Configurable within-block structure</strong>. Based on different structure and functions settings, a variety of models (such as MPNN, NLNN and other variants) could be expressed by the GN framework.</li><li><strong>Composable multi-block architectures.</strong><ul><li>Arbitrary numbers of GN blocks could be composed in sequence with shared or unshared parameters.</li><li>utilizes GN blocks to construct an encode process decode architecture and a recurrent GN-based architecture.</li><li>Other techniques for building GN based architectures could also be useful, such as skip connections, LSTM- or GRU-style gating schemes and so on.</li></ul></li></ul></li></ul></li></ul><ol start="19"><li>Applications of GNN:</li></ol><ul><li>supervised, semi-supervised, unsupervised and reinforcement learning</li><li>Structural Scenarios<ul><li>Physics</li><li>Chemistry and Biology</li><li>Knowledge graph</li></ul></li><li>Non-Structural Scenarios<ul><li>Image<ul><li>Visual Reasoning</li><li>Semantic Segmentation</li></ul></li><li>Text<ul><li>Text classification</li><li>Sequence labeling</li><li>Neural machine translation</li><li>Relation extraction</li><li>Event extraction</li><li>Other applications</li></ul></li></ul></li><li>Other Scenarios<ul><li>Generative Models</li><li>Combinatorial Optimization</li></ul></li></ul><ol start="20"><li>Problems</li></ol><ul><li>Shallow Structure</li><li>Dynamic Graphs</li><li>Non-Structural Scenarios</li><li>Scalability </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;NOTE-of-Graph-Neural-Networks-A-Review-of-Methods-and-Applications&quot;&gt;&lt;a href=&quot;#NOTE-of-Graph-Neural-Networks-A-Review-of-Methods-and-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DL_RNN</title>
    <link href="http://yoursite.com/2019/07/29/DL-RNN/"/>
    <id>http://yoursite.com/2019/07/29/DL-RNN/</id>
    <published>2019-07-29T01:22:01.000Z</published>
    <updated>2019-07-29T06:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Sequence-Model-序列模型（包括RNN）："><a href="#Sequence-Model-序列模型（包括RNN）：" class="headerlink" title="Sequence Model 序列模型（包括RNN）："></a>Sequence Model 序列模型（包括RNN）：</h4><p>1、<strong>Speech Recognition 语音识别</strong>：输入一段语音，输出英文句子（输入输出都属于Sequence Data序列数据）<br>2、<strong>Music generation 音乐生成</strong>：输入可以是空集（可以不输入，可以是数字、音乐风格），输出是音符（属于序列）<br>3、<strong>Sentiment classification 情感分类</strong>：输入是评语/一段话（属于序列），输出是衡量情感的标记<br>4、<strong>DNA Squence analysis DNA序列分析</strong>：输入给定的DNA序列，输出在DNA上标记匹配某种蛋白质的<br>5、<strong>Machine Transaction 机器翻译</strong>：输入英语一句话，输出中文的翻译<br>6、<strong>Video Activity Recognition 视频动作识别</strong>：输入以帧单位的视频，输出描述语句<br>7、<strong>Name Entity Recognition 命名实体识别</strong>：输入一句话，输出在句子中识别到的名字（常用于搜索引擎识别特殊名词）<br>8、在序列模型训练中，有输入输出都是序列数据（可能等长，可能类型不同），也有仅输入或输出才是序列模型，<br>9、命名实体识别在输入句子中，以每个单词为单位，<span style="border-bottom:2px dashed red;">输出一维向量，匹配位置，是名字的标记1，否则标记0（用X&lt;t&gt;来表示单词所在时序序列，Tx表示输入的序列长度，Ty表示输出的序列长度）</span>（这个例子也属于<strong>NLP（Natural Language Processing自然语言处理）</strong>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/17.png" alt="image"><br>10、NLP中，首要解决的是怎样表示序列里单独的单词，然后制作一个单词表/字典（在商用中字典单词经常会有3w到5w，甚至10w、100w+）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/18.png" alt="image"><br>11、在输入句子序列中，<span style="border-bottom:2px dashed red;">字典个数=每个向量的维度</span>（用one-hot的方式标记向量，用1标出在字典的位置，其他为0，一维向量）<span style="border-bottom:2px dashed red;">（若是遇到不再字典的单词，就创建一个叫做Unknown Word的伪造单词，来表示不再字典的单词）</span><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/19.png" alt="image"></p><h4 id="Recurrent-Neural-Network-RNN"><a href="#Recurrent-Neural-Network-RNN" class="headerlink" title="Recurrent Neural Network RNN:"></a>Recurrent Neural Network RNN:</h4><p>1、若是用传统的神经网络，输入x则全是one-hot的向量，而且维度会很大，输出也相同；缺点是在不同例子中可以有不同长度，Tx与Ty不一定相等，并且<span style="border-bottom:2px dashed red;">从文本位置上学到的特征并没有共享使用（若是一个人名首次被识别人名之后，在第二处，直接就可以识别成人名</span>，这才是想要的结果（计算机视觉，就是学习了小部分特征，立马推广到图片的其他地方））<br>2、<span style="border-bottom:2px dashed red;">RNN：由左到右，每次执行都添加如激活值a[i]（第一个a[0]一般初始化为0，作为伪激活），每一层都会结合上一层所得到的激活值（代表前面所有层的信息）一起预测出y，则每一层都有了联系，参数得到共享</span>（缺点是只得到前面层的信息，得不到后面层的信息，因为有时仅靠前面信息无法推定该词回事人名的单词，会有<strong>Bidirectional Recurrent Neural Network双向循环神经网络（BRNN）</strong>解决该问题）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/20.png" alt="image"><br>3、 <strong>a&lt;t&gt; = g(Waa*a&lt;t-1&gt;+Wax*X&lt;t&gt;+ba); y&lt;t&gt; = g(Wya*a&lt;t&gt;+by)</strong>（W下标，谁在前面就是求谁，在后就要乘以谁）（常用激活函数是tanh/ReLU，通常是<span style="border-bottom:2px dashed red;">tanh</span>，有其他方式可以避免梯度消失问题）（输出部分的激活函数，若是二分问题，则用sigmoid函数）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/21.png" alt="image"><br>4、 设Wa=[Waa Wax]，若Waa维度是(100,100)，Wax是(100,10000)，则Wa是(100,10100)，简化<strong>a&lt;t&gt; = g(Wa[a&lt;t-1&gt;, X&lt;t&gt;]+ba)</strong>，[a&lt;t-1&gt;, X&lt;t&gt;]维度是(10100,100)是a在上部分，X在下部分，结果a&lt;t&gt;维度是(100,100)；简化<strong>y&lt;t&gt; = g(Wy*a&lt;t&gt;+by)</strong>仅有一个下标表示输出什么类型的量<br>5、<strong>RNN反向传播backpropagation through time</strong>：基本与RNN的方向相反（前向传播顺着时间走，反向传播逆着时间走）；<span style="border-bottom:2px dashed red;">某个单词预测的损失函数使用交叉熵损失函数，整个损失值单个单词损失值之和</span><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/22.png" alt="image"></p><h4 id="不同基本模块的RNN："><a href="#不同基本模块的RNN：" class="headerlink" title="不同基本模块的RNN："></a>不同基本模块的RNN：</h4><p>1、Tx=Ty的RNN架构属于多对多类型<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/23.png" alt="image"><br>2、在情感分析的RNN中，输入是一句评语，输出判定正/负面评价（0/1二分类问题），多对一类型则在设计神经网络时，不必像多比多那样每次循环都要输出，仅在最后在输出0/1即可<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/24.png" alt="image"><br>3、在音乐生成的RNN中，输入是空集也可以，输出是一段音乐（序列），一对多类型在设计神经网络时，仅在第一次循环输入，后续循环的输入是上次循环的结果y<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/25.png" alt="image"><br>4、在多对多类型中还有Tx≠Ty的情况，机器翻译就属于其一（每种语言文字单词不全是一对一），则在设计神经网络时，(encode)就先循环输入x，(decode)输入完毕在循环输出y<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/26.png" alt="image"><br>5、一对一结构则是一种标准类型的神经网络，不需要RNN也可以</p><h4 id="Language-Model-语言模型："><a href="#Language-Model-语言模型：" class="headerlink" title="Language Model 语言模型："></a>Language Model 语言模型：</h4><p>1、<span style="border-bottom:2px dashed red;">语言模型：输入句子（文本序列 y），进行估计句子中各个单词出现的可能性/概率</span>（学习文字描述风格，在运用风格写文章）（给出部分单词，预测下一个单词）<br>2、训练集要包含 large cropus of English text 很大的英文文本语料库（cropus语料库是自然语言处理中的专业名词，意思是很多很长、用英文句子、组成的文本）<br>3、整个流程：</p><ul><li>预处理：输入一句话序列(cats average 15 hours of sleep a day)；<strong>tokenize标记化</strong>，将句子中单词转成one-hot向量（字典中的索引），<span style="border-bottom:2px dashed red;">增加一个&lt;EOS&gt;作为句子的结尾</span>，被标记为末尾y&lt;Ty&gt;（若将句号看出标志，其他符号也需要看成标志）；在出现不在字典中的单词时，将其标记问<strong>UNK(Unknown Word)</strong></li><li>设计RNN序列概率模型，<span style="border-bottom:2px dashed red;">初始化激活值a&lt;0&gt;和输入值x&lt;1&gt;为零向量，计算出a&lt;1&gt;，再softmax预测出y&lt;1&gt;概率，得出第一个单词的概率；再第二个循环中x&lt;2&gt;=y&lt;1&gt;，重复操作</span>（<strong>通过训练，预测出下一个单词，也就是学习了造句风格，在测试中可以遇到训练过的单词，会更多概率选中与风格相匹配的单词</strong>）；第一层算出概率P(y&lt;1&gt;)，第二层在第一层基础上算出概率P(y&lt;2&gt;|y&lt;1&gt;)，第三层则是P(y&lt;3&gt;|y&lt;1&gt;,y&lt;2&gt;)…最后<strong>P(y&lt;1&gt;,y&lt;2&gt;,y&lt;3&gt;)=P(y&lt;1&gt;)P(y&lt;2&gt;|y&lt;1&gt;)P(y&lt;3&gt;|y&lt;1&gt;,y&lt;2&gt;)</strong><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/27.png" alt="image"></li><li><strong>Sampling novel sequences对新序列进行采样</strong>：在训练序列模型之后，一个非正式的方法（对序列采样）可以得知这个模型学习了什么；<span style="border-bottom:2px dashed red;">对训练得到的概率分布P(y&lt;1&gt;,y&lt;2&gt;,…,y&lt;Tx&gt;)进行采样，来生成一个新的单词序列；首先初始化激活值a&lt;0&gt;和输入值x&lt;1&gt;为零向量，第一层softmax预测到的时所有单词作为第一个单词概率分布，然后进行随机采样（用np.random.choice），将第一层得到的y\<1>输出到第二层，若第一个单词选择了“the”，则第二层计算出在“the”情况下，下一个单词概率，然后再次随机采样，一直循环、采样到结束</1></span>（有可能会出现UNK，所以在采用时拒绝出现未录入字典的单词，直到不是UNK的单词）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/28.png" alt="image"></li></ul><p>4、<strong>Character-level language model 基于字符的语言模型</strong>：将每个单词字母全部拆分训练，优点是不会出现UNK，缺点是会得到太多太长的序列（一般一个句子就10~20个单词）不利于<strong>捕捉句子间的依赖关系</strong>（句子较前部分预测句子较后部分），并且计算成本高<br>5、NLP趋势是使用<strong>word level language model基于词汇的语言模型</strong>，（在计算能力好的情况下，处理大量未知文本或者专业词汇，使用基于字符的语言模型会更好）</p><h4 id="梯度消失："><a href="#梯度消失：" class="headerlink" title="梯度消失："></a>梯度消失：</h4><p>1、RNN常用tanh激活函数，因而存在有梯度消失问题，影响反向传播<br>2、基础的RNN仍是<span style="border-bottom:2px dashed red;">不擅长于捕捉长期依赖效应</span>（主语与谓语相隔较远时，时态和单双数的变化，类似的长期依赖），这需要在RNN对主语的<strong>长期记忆</strong>，才能在后面对谓语有联系<br>3、基础的RNN模型会有很多局部影响，<span style="border-bottom:2px dashed red;">比如y&lt;3&gt;就会受到其附近的值影响，在后面的值很难受到前面的影响，这个区域都很难反向传播到序列前面部分，因此神经网络很难调整前面的计算（缺点）</span><br>4、RNN也会出现梯度爆炸，相对容易发现，会直接让神经网络崩溃，参数数值会很大，甚至NaN，溢出；解决方法：<strong>gradient clipping梯度修剪</strong>（观察梯度向量，若其大于某个threshold阈值，缩放梯度向量，保证它不会太大，这就是最大值修剪）</p><h4 id="Gated-Recurrent-Unit-GRU门控循环单元："><a href="#Gated-Recurrent-Unit-GRU门控循环单元：" class="headerlink" title="Gated Recurrent Unit GRU门控循环单元："></a>Gated Recurrent Unit GRU门控循环单元：</h4><p>1、GRU能让RNN在深层网络中捕捉依赖关系，解决梯度消失问题<br>2、RNN中隐藏单元的可视化<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/29.png" alt="image"><br>3、GRU加入新变量c表示memory cell细胞，记忆细胞（在后面动词看到c时会知道主语是单数复数）：在时间t处，c&lt;t&gt;=a&lt;t&gt;（但在LSTMs他俩不相等）<strong>用c~&lt;t&gt; = tanh(Wc[c&lt;t-1&gt;,x&lt;t&gt;+bc)代替了c&lt;t&gt;</strong><br>4、GRU中心思想时，有个门<strong>Γu = sigmoid((Wu[c&lt;t-1&gt;,x&lt;t&gt;+bu)</strong>（Γ 范围是0到1，u代表更新gate，sigmoid的输出范围是[0,1]）<br>5、用c~更新c的等式，然后<span style="border-bottom:2px dashed red;">Γ 决定是否要更新它</span>（假设c&lt;t&gt;=1时表示单数，0表示复数，经过中间隔着很久，到达动词，c&lt;t&gt;仍是等于1，则动词显示单数；Γu 就决定什么时候去更新c&lt;t&gt;这个值）<strong>c&lt;t&gt; = Γu*c~&lt;t&gt; + (1-Γu)*c&lt;t&gt;</strong>（元素对应乘积）（<span style="border-bottom:2px dashed red;">当Γu=1时，c&lt;t&gt;=1，对于主谓语之间的语句 Γu=0，也就是c&lt;t&gt;=c&lt;t-1&gt;，不用进行更新</span>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/30.png" alt="image"><br>6、因为sigmoid的值，Γu很容易取到0，则c&lt;t&gt;一直维持值不变，因为Γ很接近0，可能是0.000001，c&lt;t&gt;不变，a&lt;t&gt;值也维持不变，这就不会出现梯度消失了<br>7、c&lt;t&gt;可以是个向量，若有100个隐含依赖，则可以是100维，Γ也是相同维度，就是100bit的向量（里面几乎全是0或者1）（Γ不会确切的等于0或者1，会是0到1的中间值，为了理解可以当成0和1）<br>8、完整的GRU公式（会多一个Γr相关门）（GRU和LSTM都十分常用）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/31.png" alt="image"></p><h4 id="Long-Short-Term-Memory-LSTM长短期记忆网络："><a href="#Long-Short-Term-Memory-LSTM长短期记忆网络：" class="headerlink" title="Long Short-Term Memory LSTM长短期记忆网络："></a>Long Short-Term Memory LSTM长短期记忆网络：</h4><p>1、比GRU更加有效，是比GRU更通用更强<br>2、在LSTM中得公式，</p><ul><li>c~&lt;t&gt; = tanh(Wc[a&lt;t-1&gt;,x&lt;t&gt;+bc)</li><li>Γu = sigmoid((Wu[a&lt;t-1&gt;,x&lt;t&gt;+bu)    update gate</li><li>Γf = sigmoid((Wf[a&lt;t-1&gt;,x&lt;t&gt;+bf)    forget gate</li><li>Γo = sigmoid((Wo[a&lt;t-1&gt;,x&lt;t&gt;+bo)     output gate</li><li>c&lt;t&gt; = Γu*c~&lt;t&gt; + Γf*c&lt;t-1&gt;（Γf代替1-Γu）</li><li>a&lt;t&gt; = Γo*tanh(c&lt;t&gt;)<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/32.png" alt="image"><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/33.png" alt="image"></li></ul><p>3、设置了forget gate和update gate，则LSTM很容易把c&lt;0&gt;一直传递下去<br>4、在三种gate的计算下，只需要a&lt;t-1&gt;和x&lt;t&gt;，也可以加入c&lt;t-1&gt;，这称为<strong>peephole connection窥视孔连接</strong>（则gate的值也由记忆细胞的值一同决定）<br>5、GRU实在LSTM中做出的简化，GRU设计更简单，只有两个gate，容易创建更大规模更深的网络</p><h4 id="Bidirectionnal-RNN-双向RNN："><a href="#Bidirectionnal-RNN-双向RNN：" class="headerlink" title="Bidirectionnal RNN 双向RNN："></a>Bidirectionnal RNN 双向RNN：</h4><p>1、因为单向的 RNN中的单个单词只被其前面的单词所影响，但很多情况影响其的意义来源于后面的内容，因此需要双向RNN<br>2、BRNN，也是一个Acyclic graph无环图，正反向独立运行，（正反向前向传播均属于是前向传播）（可以由前后内容一同判断一个单词）缺点是，<span style="border-bottom:2px dashed red;">需要完整的序列才能预测任意位置，例如做语音识别，需要等这个人把话说完才能进行识别</span><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/34.png" alt="image"><br>3、<strong>y&lt;t&gt; = g(Wy[a→&lt;t&gt;,a←&lt;t&gt;]+by)</strong></p><h4 id="Deep-RNNs"><a href="#Deep-RNNs" class="headerlink" title="Deep RNNs:"></a>Deep RNNs:</h4><p>1、在标准的RNN上，垂直方向多加三趟循环，加上水平时间线上输入x<tx>，已经是很深层了（与卷积100层不一样），会有很多隐含层，计算量十分大<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/35.png" alt="image"><br>2、a[2]&lt;3&gt; = g(Wa[2][a[2]&lt;2&gt;, a[1]&lt;3&gt;]+ba[2])<br>3、第1层有Wa[1]、ba[1]；第2层有Wa[2]、ba[2]；第3层有Wa[3]、ba[3]</tx></p><h4 id="Word-Representation-词汇表征："><a href="#Word-Representation-词汇表征：" class="headerlink" title="Word Representation 词汇表征："></a>Word Representation 词汇表征：</h4><p>1、<strong>Embedding 词嵌入</strong>：语言表示的一种方式，<span style="border-bottom:2px dashed red;">可以让算法自动的理解一些类似的词</span>（比如 男人女人、国王王后）（意思是将众多的单词按特征归类）<br>2、通过词嵌入可以构建NLP应用，即使模型的训练集相对小也可以（需要通过一些方法消除词嵌入的偏差）<br>3、用one-hot向量表示单词在字典的位置，会把单词都独立起来，这样泛化能力不强（<span style="border-bottom:2px dashed red;">可以通过300个特征来联系这些单词，但是实际上联系效果还是不够</span>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/36.png" alt="image"><br>4、<strong>特征化</strong>：可以将300维的特征向量嵌入到二维空间，即可可视化了（常用可视化算法是t-SNE算法，非线性）；可以更直观发现特征相似的词都聚集在一起<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/37.png" alt="image"><br>5、<strong>命名实体识别词嵌入的迁移学习</strong>：在大量无标签文本中学习大量词嵌入（也可以下载已训练好的模型，则可以将自己少量的训练集迁移学习，除非训练集很大，否则不需要再次调整词嵌入，直接使用就好）<br>6、词嵌入的运用十分广泛（<strong>named entity recognition命名实体识别</strong>、<strong>text summarization文本摘要</strong>、<strong>co-reference resolution 文本解析</strong>、<strong>parsing指代消解</strong>）；在语言模型之类的训练，则较少用到（因为会有大量数据）<br>7、词嵌入特征是能帮助实现<strong>analogy reasoning类比推理</strong>（虽然没有在NLP中着重运用，但能让人看到词嵌入干了什么，能干什么）；当男人能推出女人时，国王也能推出女王，得出他们差别都在性别（<strong>Eman-Ewomen ≈ Eking-Equeen</strong>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/38.png" alt="image"><br>8、求<strong>Ew</strong>(Equeen)：<strong>argmax sim(Ew, Eking-Eman+Ewomen)</strong> 相似最大化；通过方程找导最理想结果（准确率一般只有30%~70%）（常用的similarity function相似度函数时<strong>cosine similarity余弦相似度 sim(u,v)=(u^T * v)/(||u|| ||v||)，就是求u、v的俩向量的夹角Φ余弦值</strong>（cos函数中，Φ=0时，cos值是1；Φ=2PI 时，cos值是-1；就是两者越是相似，角度Φ越小，越接近1，越大则不相似则会接近-1））（<span style="border-bottom:2px dashed red;">相同关系的推断：线性，同特征的推断会使向量趋向平行</span>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/39.png" alt="image"><br>9、还可以用<strong>平方距离/欧式距离||u-v||^2</strong>求差异表示相似度<br>10、学习词嵌入就是学习一个嵌入矩阵，嵌入矩阵E，维度(300,1000)，与one-hot向量o，维度(1000,1)；<strong>E·o=e</strong>（o向量在E中的<strong>嵌入向量e</strong>(300,1)）（但不常用矩阵乘积的方法找e，计算量太大，矩阵乘积慢，会有单独函数方法来直接找到E中的哪一列）<br>11、词嵌入的NLP过程，求得每个嵌入向量e，最终汇聚于全连接层和softmax输出，做出多个单词的概率计算，最高概率则是预测单词（也可以仅看前4个单词即可推出，适当减少参数；或者仅提供其前面的/附近的一个单词也可）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/40.png" alt="image"><br>12、<strong>Word2Vec算法的skip-gram模型</strong>：（用于学习词嵌入更高效）抽取上下文单词于目标词匹配，来构造一个监督学习问题（Content c “orange” -&gt; Target t “juice”）（<strong>o_c -&gt; E -&gt; e_c -&gt; softmax -&gt; y^</strong>）（softmax：<strong>p(t|c)=(e^(θt^T * e_c))/(Σj e^(θj^T·e_c)</strong>)（θt是一个输出t的参数））（softmax损失函数：<strong>L(y^,y)=-Σi yi log y^</strong>）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/41.png" alt="image"><br>13、关键的p(t|c)中分母运算太大使得操作变慢；解决方法：使用hierarchical分级的softmax分类器（类似折中查找一样，每次二分为一查找，提高速度（也类似哈夫曼树，使用频率高的词靠近root））<br>14、<strong>Negative Sample 负采样</strong>：（与skip-gram模型做的相类似，但效率会更好）构造新的监督学习，给定一对单词，去预测是否是一对content-target的组合（<strong>context：orange-juice 输出target 1属于正样本；context：orange-king 输出target 0属于负样本</strong>）（k次随机在字典中寻找词与orange匹配得出负样本，提供作为训练集）（数据集小的话k一般取5~20；数据集大k选2~5即可）；可以使用<strong>logistic回归模型</strong>，p(y=1|c,t)=sigmoid(θt^T·e_c)；在整个训练中，训练一个正样本、随机k个负样本，就不需要每次在softmax中分母运算高纬度求和<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/42.png" alt="image"><br>15、在负采样中负样本的word如何选？推出该公式用于选取负样本的word（对词频的3/4次方，再求在总和的比例）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/43.png" alt="image"><br>16、（难）<strong>GloVe word vector 词向量算法</strong>：用词表示全局变量，明确context-target的关系Xij（i、jb表示两个词，Xij=Xji（若i、j相邻，则不符合这个对称等式）可将i、j定义为两个位置相近的单词，假设左右各10词的距离）；Xij可获取单词i、j出现位置相近时或者彼此接近时的频率的计数器<br>17、（难）<strong>GloVe’s Model</strong>：最小化它们的差值 <strong>minimize=ΣiΣj f(Xij)((θi^T·ej+bi+bj-logXij)^2</strong>；表示两个单词关系多紧密（防止Xij=0，导致无穷大，需添加一个weighting term加权项f(Xij)项，当Xij=0，f(Xij)=0）；<span style="border-bottom:2px dashed red;">不给频繁词过大的权重，不给少用词太小的权重</span>；θ和e是对称的，将其颠倒或排序，都可以输出最佳结果；训练方法是将他们一致地初始化，然后梯度下降来最小化输出，当每个词处理完之后，取平均值（e(find)=(e_w+θ_w)/2）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/44.png" alt="image"><br>18、<strong>Sentiment classification情感分析</strong>：分细一段评语，判断是否喜欢讨论的东西；这个任务的标记训练集可能没有那么多，可用词嵌入；可用于收集消费者的评价<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/45.png" alt="image"><br>19、训练嵌入矩阵E会很大维度（若在很大训练集上训练E，则会学到很多知识）；在特征向量求得需要平均化在送入softmax；<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/46.png" alt="image"><br>20、只把词的特征向量，加起来，可能就理解不了“反话”，则需要RNN<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/47.png" alt="image"><br>21、<strong>debiasing word embedding 词嵌入消除偏见</strong>：在使用词嵌入时需要减少或者消除词嵌入（一个完成词嵌入可能会输出Man:Computer_Programmer as Woman:Homemake / father:doctor as mother:nurse这种性别歧视的话语）；<span style="border-bottom:2px dashed red;">根据训练模型使用的文本，词嵌入能反映出性别、种族、年龄、性取向等的这些偏见</span>（这些偏见都跟社会经济状态相关，机器学习作出决策时不应该存在偏见）<br>22、步骤：1）辨别出想要减少的或者消除的特定偏见趋势（将(e_he - e_she)和(e_male - e_female)这类的男女性别的差值求和再简单取平均值）；2）neutralize step中和步，对那些定义不确切的词，可以将其处理下，避免偏见；3）Equalize pairs 均衡步，类似girl和boy能够有一致的相似度（距离中立词语能有相等距离）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/48.png" alt="image"></p><h4 id="Basic-Models-基础模型："><a href="#Basic-Models-基础模型：" class="headerlink" title="Basic Models 基础模型："></a>Basic Models 基础模型：</h4><p>1、<strong>seq2seq的机器翻译（法语转英语）</strong>：将法语句子序列转成输入向量x，英语句子为y；<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/49.png" alt="image"><br>输入需要先经过一个<strong>encoder network编码网络</strong>（属于RNN，隐含单元可以是GRU/LSTM）（<span style="border-bottom:2px dashed red;">输入法语，在输出一个能代替法语的 向量，更好进行训练</span>）；在后面可以建立一个<strong>decoder network解码网络</strong>（输出英语，直到输出结束标志）（这一部分RNN与语言模型的RNN基本一致）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/50.png" alt="image"><br>2、<strong>Image captioning图像描述</strong>（用一句话描述图片）：在卷积神经网络（AlexNet）中先识别图片（可以算作图像的编码网络（得到一个4096的一维向量）），然后用RNN生成图片的描述（作为解码网络）<br>3、可以将机器翻译称为有条件的语言模型<strong>P(y&lt;1&gt;,y&lt;2&gt;,…,y&lt;Ty&gt;|x)</strong>；<span style="border-bottom:2px dashed red;">在机器翻译可能会翻译出多条句子，虽然没错但不是最好的翻译</span>（最好的翻译结果句子的P(y|x)是最高的），则需要一种算法将找到合适的y值，再将其最大化（常用算法为<strong>Beam Search束搜索</strong>）（Greedy search贪心搜索算法不可用，最常用的搭配不见得是最好的翻译结果，并且每个词都需要遍历所有去寻找最好的，计算量是字典总数的指数级别）<br>4、<strong>Beam Search集束搜索</strong>：</p><ul><li>首先在解码网络中，需要在字典10000的单词中，挑选出输出的第一个单词P(y&lt;1&gt;|x)，会考虑选多个的单词（<span style="border-bottom:2px dashed red;">参数B，称为beam width集束宽，B=3则一次会考虑三个单词</span>）将所挑选的单词概率存入计算机内存里；</li><li><p>在所选的三个单词，分别再其基础上选择第二个单词P(y&lt;2&gt;|x,y&lt;1&gt;)，<span style="border-bottom:2px dashed red;">但最主要是找到最大概率<strong>P(y&lt;1&gt;,y&lt;2&gt;|x) = P(y&lt;1&gt;|x) * P(y&lt;2&gt;|x,y&lt;1&gt;)</strong></span>；第二步就有30000种可能了，然后在这30000可能中找出3个最高的概率的y&lt;1&gt;,y&lt;2&gt;继续下个30000的概率选择；主要乘积概率公式如下：<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/51.png" alt="image"></p></li><li><p>重复类似第二步的操作，每一步增加一个单词，直至识别结束符号；当B=1时，就变成了贪婪搜索</p></li></ul><p>5、<strong>Length normalization 长度归一化</strong>：对集束搜索的稍微调整；因为通过beam search公式所求概率通常小于1，多次小于1的概率乘积，会变得很小很小，导致数值下溢，计算机精度不够无法精准存储；<span style="border-bottom:2px dashed red;">改造公式为对数的求和，更加稳定，不容易出现四舍五入的误差避，免数值下溢（对数函数单调递增，所以最大化logP(y|x)与最大化P(y|x)是一回事）</span>；<br>6、（因为每次都会乘以小于1的概率，所以也会偏向更少数量的输出）<span style="border-bottom:2px dashed red;">因为最短也不一定是最好的输出，所以不再最大化概率了，改为归一化，求概率对数的平均值</span>；在取平均数时，如何选择分母才会更好，在分母设置参数α，Ty^a作为分母会更柔和一点，α可以设置为0.7；α=0则等于没有归一化，α=1则等于完全用长度来归一化；用调整后的α会得到更好的结果<br>7、对于B的选择，一般越多还是越好，但过多计算成本就会变高；B很大的情况：会得到更好的结果，计算会慢一些，占用内存大；B很小的情况：结果不会很好，但计算快，占用内存少；<span style="border-bottom:2px dashed red;">一般在实际使用会设置B=10</span>；设置为100就太大了，但在科研需要更好的效果则会设置成1000或者3000<br>8、运用广度优先搜索或者深度优先搜索可能会比集束搜索速度更快，但不能保证一定找到最大化的精准的最大值<br>9、误差分析可以节省时间，用更多时间投入更有用的工作<br>10、集束搜索算法是一种<strong>approximate search近似搜索算法/heuristic search启发式搜索算法</strong>，不直接输出最好的句子，而是记录多个好句子，再输出最好的<br>11、人工翻译的句子记为y*、RNN输出结果记为y^；人工翻译比RNN输出要好的前提下，对比P(y*|x)和P(y^|x)（忽略归一化复杂情况下）</p><ul><li>case1：P(y*|x)&gt;P(y^|x)，则beam search出问题了（加大B），没有找到更大的y^</li><li>case2：P(y*|x)&lt;=P(y^|x)，则是RNN出问题了（加深网络），y*翻译试比y^好的，但RNN算出P(y*|x)&lt;=P(y^|x)</li></ul><p>12、持续多次句子翻译的对比P(y*|x)和P(y^|x)，出现最多错的就是最主要误差问题</p><h4 id="Bleu-score："><a href="#Bleu-score：" class="headerlink" title="Bleu score："></a>Bleu score：</h4><p>1、用于代替人类去评估机器翻译结果，衡量准确性（给定一个翻译结果，计算出一个分数，接近人类的翻译就高分）；衡量机器翻译质量的方法之一是<span style="border-bottom:2px dashed red;">观察输出结果的每一个词，看其是否出现在人工翻译参考当中</span>（精确度）（但是出现个别情况，输出所有单词一样，并且其都在人工翻译中出现，会出现精度很好，但翻译出的句子不行）；改良后的方法：<span style="border-bottom:2px dashed red;">记录每一个词在出现在人工翻译中的次数，在多个人工翻译句子里面出现最多次数视为上限，上限为分子，在机器翻译的结果中出现的次数为分母</span>；<strong>体现出翻译结果与人工翻译的重叠层度</strong>（若是与人工翻译一致，则P=1.0）（可以下载已有的模型）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/52.png" alt="image"><br>2、<strong>Bleu score on brigrams（二元组）（相邻两个单词）</strong>：（unigrams一元组）（也会有trigrams三元组）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/53.png" alt="image"><br>3、一元组精度公式：<strong>P1=Σ</strong>unigram∈y^ <em> <strong>Count</strong>clip<strong>(unigram) / Σ</strong>unigram∈y^ </em> <strong>Count(unigram)</strong><br>4、n元组精度公式：<strong>Pn=Σ</strong>n-gram∈y^ <em> <strong>Count</strong>clip<strong>(n-gram) / Σ</strong>n-gram∈y^ </em> <strong>Count(n-gram)</strong><br>5、结合Bleu score，采用BP（<strong>brevity penalty简短惩罚</strong>）的惩罚因子作为调整因子，<strong>BPexp(1/4 Σ4 Pn)</strong>（对P1、P2、P3、P4取均值）；<span style="border-bottom:2px dashed red;">若是输出一个很短的翻译则会得到很高的精确度，但简短的输出也不一定是最好</span>；机器翻译长度大于人工翻译，BP=1<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/54.png" alt="image"></p><h4 id="（难）Attention-Model-注意力模型："><a href="#（难）Attention-Model-注意力模型：" class="headerlink" title="（难）Attention Model 注意力模型："></a>（难）Attention Model 注意力模型：</h4><p>1、在翻译一段文本中，人类大部分是翻译一部分，再翻译下一部分，而不是看完全部，再靠记忆去由零开始翻译<br>2、Bleu score在短文翻译和长达30字以上的文本翻译都会比较难，所以分数较低<br>3、注意力模型就会让其变得更像人类一样翻译文本，在长文本中表现良好<br>4、<span style="border-bottom:2px dashed red;">利用BRNN，但每层的输出并不会直接输出翻译结果，而是输出<strong>α&lt;t,t’&gt;“注意力权重”</strong>用于接入新的RNN的<strong>S&lt;t&gt;“注意力权重集”</strong>（注意力权重则是一个注意力权重集对BRNN这层的所需要的注意力），S&lt;t&gt;的输入会是对应单词和其上下文单词（多个输入），再逐个输出翻译的单词</span><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/55.png" alt="image"><br>5、上下文的定义是<span style="border-bottom:2px dashed red;">被注意力权重除权的不同步时间中的特征值</span>；BRNN多个输出α&lt;t,t’&gt;相加得出<strong>c&lt;t&gt;</strong>，c&lt;t&gt;在统一输入注意力权重集（<strong>c&lt;t&gt;=Σα&lt;t,t’&gt;*a&lt;t’&gt;</strong>）（<strong>Σα&lt;t,t’&gt;=1</strong>）（用softmax来确保这些权重加起来等于1）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/56.png" alt="image"><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/57.png" alt="image"><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/58.png" alt="image"><br>6、如果想要决定花多少注意力在t’的激活值上，很大程度取决于上一个时间步的s&lt;t-1&gt;的隐藏状态的激活值<br>7、缺点是算法复杂度是O(n^3)，总参数个数会是Tx*Ty，但是一部分一部分翻译的话，这个消耗还是很可接受<br>8、注意力模型还被应用于将任何形式的时间表达方法转化成标准时间显示方式<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/59.png" alt="image"><br>9、注意力权重的可视化，需要更多注意力的色块会更亮<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/60.png" alt="image"></p><h4 id="Speech-Recognition-语音识别："><a href="#Speech-Recognition-语音识别：" class="headerlink" title="Speech Recognition 语音识别："></a>Speech Recognition 语音识别：</h4><p>1、seq2seq在音频上的应用（输入音频，输出文本）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/61.png" alt="image"><br>2、音频数据的常见预处理步骤：运行这个原始的音频片段，然后生成一个<strong>spectrogram声谱图</strong>（不同颜色表示声波能量的大小）；<strong>false blank output伪空白输出</strong>（模仿人耳）也常应用于预处理<br>3、曾经也有人工设计的<strong>phonemes音位</strong>作为基本单元（就是听发音判别单词）<br>4、采用<strong>CTC损失函数（connectionist temporal classification）</strong>来做语音识别；例如”the quick brown fox”一句话十秒，每秒100hz，则有1000层输入（模型较为简单，但很深）；虽然输入有1000，但输出是没有1000，则需要用到CTC，整合输出”ttt__h_eee____ __qq__…”类似的以赫兹输出音频（CTC：将空格之间的重复字符折叠起来成为一个单词）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/62.png" alt="image"></p><h4 id="Trigger-word-detect触发检字："><a href="#Trigger-word-detect触发检字：" class="headerlink" title="Trigger word detect触发检字："></a>Trigger word detect触发检字：</h4><p>1、类似”ok，google！”一样的唤醒语音系统，然后发出一条语音指令，再识别后执行某些事<br>2、设备一直检测着附近的音频，输入音频，提取出音频中的特征，将特征输入RNN，再没有识别到关键字的时候，输出0，检测到关键字时输出1；缺点是0太多了，导致训练集很不平衡；<span style="border-bottom:2px dashed red;">一个暴力解决方法（在输出1后，固定一定时间保持输出1，达到一定平衡）</span>，起码是训练集更加平衡些，更好于训练<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/63.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Sequence-Model-序列模型（包括RNN）：&quot;&gt;&lt;a href=&quot;#Sequence-Model-序列模型（包括RNN）：&quot; class=&quot;headerlink&quot; title=&quot;Sequence Model 序列模型（包括RNN）：&quot;&gt;&lt;/a&gt;Seque
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Blockchain</title>
    <link href="http://yoursite.com/2019/07/19/Blockchain/"/>
    <id>http://yoursite.com/2019/07/19/Blockchain/</id>
    <published>2019-07-19T00:51:03.000Z</published>
    <updated>2019-11-14T12:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>比特币和以太坊均是区块链技术下一种<strong>crypto-currency加密货币</strong></li><li><strong>比特币：</strong>密码学基础、比特币的数据结构、共识协议和系统实现、挖矿算法和难度调整、比特币脚本、软分叉和硬分叉、匿名和隐私保护</li><li><strong>以太坊：</strong>基于账户的分布式账本、数据结构（状态树、交易树、收据树）、GHOST协议、挖矿（memory-hard mining puzzle）、挖矿难度调整、权益证明（Casper the Friendly Finality Gadget(FFG)）、智能合约</li></ul><h4 id="密码学基础："><a href="#密码学基础：" class="headerlink" title="密码学基础："></a>密码学基础：</h4><p>1、加密货币是不加密的 ，所有信息是公开的，交易金额与时间都是公开的<br>2、比特币中用到密码学的两大功能：<strong>哈希</strong>、<strong>签名</strong><br>3、<strong>cryptographic hash function 哈希</strong>：有两大性质（<strong>collision resistance哈希碰撞</strong>）（<strong>hiding计算过程是单向的、不可逆的</strong>）<br>4、哈希碰撞：当有两个互不相等的输入x和y，而H(x)=H(y)），则称为哈希碰撞；其是不可避免地，但是客观存在；作用是在H(m)计算出来，很难几乎找不到有另外m’的H(m’)=H(m)，则是<span style="border-bottom:2px dashed red;">没有办法再对m作出修改后，不被检测出来（找不到人为的哈希碰撞）</span><br>5、hiding：计算过程无法逆推，<span style="border-bottom:2px dashed red;">则是哈希结果并不会泄露原本信息</span>（前提是输入也是足够大，输入分布要比较均匀，取值概率差不多，否则可以蛮力破解）<br>6、<strong>collision resistance + hiding = digital commitment = digital equivalent of a sealed envelope</strong>    （sealed envelope表示现实生活中的公信机制）<br>7、在输入数量数值不够大时，<span style="border-bottom:2px dashed red;">需要随机数nonce</span>，则H(x)，变为H(x||nonce)，才不会被蛮力破解<br>8、除了密码学基础两大性质之后，还需要一个性质<strong>puzzle friendly</strong>（<span style="border-bottom:2px dashed red;">指就算得到哈希结果，事先是不知道哪个输入会得到该结果</span>）<br>9、挖矿就是寻找nonce，nonce与块头的其他信息组合，然后需要H(block header)&lt;=target（区块链时链表，每块有个块头，块头有很多域设置信息，其中一个就是设置nonce）（<span style="border-bottom:2px dashed red;">挖矿就是不断试不同nonce，然后放入块头进行哈希运算，得出结果落在target space指定范围内</span>）（只有不断试nonce才行，没有其他方法，这也代表了工作量）（一旦找到nonce发布出去，计算一次哈希就可以验证是否正确，称为difficult to solve解决很难，easy to verify验证很简单）<br>10、比特币中所用的哈希函数：<strong>SHA-256</strong>（Secure Hash Algorithm）<br>11、比特币账户，去中心化，在本地创立公钥与私钥（public key, private key）即可，就是一个账户，运用asymmetric encryption algorithm非对称加密算法（<strong>加密用公钥，解密用私钥</strong>）（公钥是公开的（相当于账号），私钥是保留本地的（相当于账户密码），<span style="border-bottom:2px dashed red;">发送方用接收方的公钥加密信息，接收方用其私钥解密</span>）<br>12、公钥 私钥适用于签名，每次交易，<span style="border-bottom:2px dashed red;">发送方需要在交易信息发送前用私钥进行签名</span>（才能确保是发送方发出，而不是冒名顶替，可以用公钥验证是否本人）<br>13、两个人公钥私钥相同的概率可忽略不计（前提是生成公钥私钥的随机源要好，否则就会出现该情况）</p><h4 id="比特币的数据结构："><a href="#比特币的数据结构：" class="headerlink" title="比特币的数据结构："></a>比特币的数据结构：</h4><p>1、hash pointer哈希指针：需要存地址和哈希值<br>2、区块链与普通链表区别是：用了哈希指针代替了普通指针（第一个块是系统产生的，称为genesis block创世纪块），这个结构可以实现tamper-evident log防篡改日志，<span style="border-bottom:2px dashed red;">一旦篡改区块的哈希信息，后面区块哈希信息不匹配</span>，就连接不上了（有了这个机制，可以仅保留目前几个区块就可以了，要是需要前面的区块，可以向系统索取）<br>3、Merkle Tree（结构之一）：哈希指针的二叉树（叶子节点都是data block数据块（交易信息），非叶子节点都是hash point哈希指针）（知道一个root的哈希值，只要有一个地方发生改变，均可知道，只要一改变，哈希值就对不上了）（树比链表结构更优，遍历速度快）<br>4、每个区块分成block header块头和block body块身，交易信息在块身<br>5、<strong>merkle tree</strong>提供merkle proof证明<br>6、比特币节点分成两类：<span style="border-bottom:2px dashed red;">全节点（有块头块身，有交易信息，类似比特币客户端）清节点（仅保留块头，块头仅有root哈希值，用于个人用户，则无法知道交易是否被提交到区块链，需要merkle proof验证）</span><br>7、merkle proof就是可以查询交易的叶子节点，一直往根节点查询，整个路径；<span style="border-bottom:2px dashed red;">需要向全节点请求提供图中红色节点哈希值，即可计算出root哈希值，再进行对比</span>即可知道是否存在该交易（但仅仅能验证该分支的正确性，其他分支无法验证），merkle proof过程称为proof of memebership / proofof inclusion，其复杂度为O(log(n))<br><img src="https://github.com/soloistben/images/raw/master/block_chain_image/merkle_tree.jpg" alt="image"><br>8、要证明一个交易节点不在merkle tree中，需要得到整个树，得到所有叶子节点，在排除，复杂度是O(n)；若是先将叶子节点的哈希值进行排序，则可以根据哈希值找到两个叶子节点（即范围），在验证一下俩节点哈希值往上到root哈希是否正确，若正确，则该交易点不在merkle树中<br>9、只要无环数据结构，都可以用上哈希指针，有环就不可以</p><h4 id="共识协议："><a href="#共识协议：" class="headerlink" title="共识协议："></a>共识协议：</h4><p>pass</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;比特币和以太坊均是区块链技术下一种&lt;strong&gt;crypto-currency加密货币&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比特币：&lt;/strong&gt;密码学基础、比特币的数据结构、共识协议和系统实现、挖矿算法和难度调整、比特币脚本、软分叉和硬分
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DL_CNN</title>
    <link href="http://yoursite.com/2019/07/03/DL-CNN/"/>
    <id>http://yoursite.com/2019/07/03/DL-CNN/</id>
    <published>2019-07-03T02:29:01.000Z</published>
    <updated>2019-07-29T05:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="激活函数："><a href="#激活函数：" class="headerlink" title="激活函数："></a>激活函数：</h4><p>1、sigmoid常用于二元分类在输出时做激活函数，其他地方tanh更优于sigmoid<br>2、tanh和sigmoid在过大过小时都会出现梯度为零（斜率为0，与x轴平行），则更多选择使用relu（rectified linear unit修正线性单元）（在x=0处不可导，但实际情况很少会出现靠近0的数，则可以忽略）（不确定用什么激活函数，就用relu）（<span style="border-bottom:2px dashed red;">relu不会出现梯度弥散</span>，则会更快）<br>3、 leaky relu（g(z)=max(0.01z,z)）在x&lt;0时有梯度 ，relu在x&lt;0时没有梯度<br>4、选择什么激活函数：在多事几个激活函数训练下，选择使参数更优的激活函数<br>5、若激活函数全是线性函数，则隐含层没有意义，整个神经网络都仅仅只是线性运算<br>6、线性函数作为激活函数一般是在输出时（全连接层）<br>7、实际上大多数现象呈现关系都是正相关关系，并非线性关系，因此用非线性函数作为激活函数是更适合表达正相关关系</p><h4 id="激活函数的导数："><a href="#激活函数的导数：" class="headerlink" title="激活函数的导数："></a>激活函数的导数：</h4><p>1、sigmoid的导数 =&gt; g’(z) =g(z)(1-g(z))，z=0时g’(0)=1/4<br>2、tanh的导数 =&gt; g’(z) = 1-(g(z))^2，z=0时g’(0)=1<br>3、relu的导数 =&gt; g’=0(z&lt;0),g’=1(z&gt;0),z=0时，g’=0或1都可以（不重要，z=0概率太小）<br>4、leaky relu的导数 =&gt; g’=0.01(z&lt;0),g’=1(z&gt;0)</p><h4 id="梯度下降："><a href="#梯度下降：" class="headerlink" title="梯度下降："></a>梯度下降：</h4><p>1、不可以将所有参数初始化为0，否则梯度下降会失效（偏置初始化为0可以，权重初始化为0则会出现问题）<br>2、权重初始化一般都比较小，过大会在tanh和sigmoid中梯度太小甚至出现梯度弥散，使得梯度下降过慢</p><h4 id="前向传播反向传播："><a href="#前向传播反向传播：" class="headerlink" title="前向传播反向传播："></a>前向传播反向传播：</h4><p>1、为什么要更深的神经网络？<br>​    在相同节点情况下，深比浅更快（树的类型）<br>2、每次执行一个神经元节点运算（激活函数g(wx+b)），都会缓存z=wx+b的值，作为激活函数的输入和反向传播的输入</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><p>1、反向传播输出每一层的dw和db，则会更新下一轮的w=w-dw，b=b-db（<span style="border-bottom:2px dashed red;">参数越来越优，越接近真实值，dw、db就会越来越小</span>）<br>2、参数：w、b  超参数：学习率，激活函数，隐含层层数等（均影响w和b的值）<br>3、深度学习，机器学习是迭代的过程，不可能一开始就直接把所有超参数全部设置好</p><h4 id="数据划分："><a href="#数据划分：" class="headerlink" title="数据划分："></a>数据划分：</h4><p>1、数据集一般分为train训练集、dev验证集（验证方差、偏差）、test测试集（泛化性）<br>2、对于小数据，训练:测试=&gt;7:3，训练:验证:测试=6:2:2<br>3、对于大数据，验证集与测试集只需要小比例数据即可，验证集有1w(1%)数据即可用于在多种算法选出最优的几个算法，测试集有1w(1%)就可以评估模型性能，尽可能多数据用于训练<br>4、<span style="border-bottom:2px dashed red;">直接用网络图片，会导致训练集与测试集和验证集不是来自于同一分布</span></p><h4 id="方差与偏差："><a href="#方差与偏差：" class="headerlink" title="方差与偏差："></a>方差与偏差：</h4><p>1、训练集误差小，验证集误差大，可能会是过拟合，属于高方差<br>2、训练集与验证集误差相差不大，但其他分类有明显差距，可能是欠拟合，属于高偏差<br>3、训练集误差大，验证集误差更大，则属于高偏差与高方差<br>4、训练集验证集的误差都小，则属于低偏差与低方差<br>5、一般最优误差是贝叶斯误差，几乎接近0误差<br>6、若高偏差，则需要更深的神经网络or更长时间训练or更好的优化算法<br>7、若偏差不高，则判断是否高方差<br>8、若高方差，则需要更多数据or正则化<br>9、优化目标要做到低方差、低偏差</p><h4 id="正则化："><a href="#正则化：" class="headerlink" title="正则化："></a>正则化：</h4><p>1、用L1正则化，会使w变稀疏，但未改变所占内存大小，并不便于减小权重<br>2、常用L2正则化，但计算量会增大<br>3、使用正则项，可避免数据权值矩阵过大，正则系数过大，使w过小，会减少过拟合，接近高偏差状态<br>4、w越小，z=wx+b也越小，靠近0处的范围，则在tanh和sigmoid激活函数中，激活函数大致呈线性状态，使梯度（斜率）保持较大状态<br>5、在代价函数J加入正则化项，是为了预防权重过大<br>6、代价函数对于梯度下降的每个调幅都单调递减</p><h4 id="Dropout："><a href="#Dropout：" class="headerlink" title="Dropout："></a>Dropout：</h4><p>1、dropout中的keep-prop概率表示每个隐藏单元的不被消除概率<br>2、使用dropout会减小权重，类似正则化，并且完成了一些预防过拟合的外层正则化<br>3、<span style="border-bottom:2px dashed red;">在过拟合严重处可降低keep-prop，不担心过拟合处可提高keep-prop</span><br>4、一般不在输入层使用dropout<br>5、除非出现过拟合状态，否则不用dropout，<span style="border-bottom:2px dashed red;">在计算机视觉常用dropout，在别的领域少用</span><br>6、dropout缺点是代价函数J不再被明确定义<br>7、先执行代码，确保代价函数是单调递减，再使用dropout</p><h4 id="其他减少过拟合方法："><a href="#其他减少过拟合方法：" class="headerlink" title="其他减少过拟合方法："></a>其他减少过拟合方法：</h4><p>1、data augment数据增强，在少图片数据时增多图片数据，有一定减少拟合作用<br>2、early stopping提早结束，在出现过拟合前（验证集误差提高前）获得中等大小的w范数，提早结束训练。缺点时停止了代价函数的降低和停止了优化</p><h4 id="正则化输入："><a href="#正则化输入：" class="headerlink" title="正则化输入："></a>正则化输入：</h4><p>1、归一化特征值输入可以加速神经网络的训练，将代价函数的图像不均匀显示（输入参数之间取值范围差别过大），则将图像显示更加均匀（重建坐标系将输入参数之间范围缩至相差不多）则可以使梯度下降更快<br>2、z=wx+b （w比1大）过大引起梯度爆炸，（w比1小）过小引起梯度弥散<br>3、高斯随机变量初始化权重w，会有一定程度减少发生梯度爆炸和梯度弥散的情况（relu激活函数使用2/n的方差，tanh使用1/n的方差）</p><h4 id="梯度检测："><a href="#梯度检测：" class="headerlink" title="梯度检测："></a>梯度检测：</h4><p>1、梯度检测不要用在训练，用于调试（dθapprox[i]计算需要很长时间，dθ要反向传播计算，所以在调试计算比较好）<br>2、梯度检测结果不好，要检查所有项，找出bug<br>3、若使用了正则化，代价函数不能漏掉正则项<br>4、<span style="border-bottom:2px dashed red;">梯度检测不能使用dropout，使用dropout无法确认代价函数</span></p><h4 id="mini-batch："><a href="#mini-batch：" class="headerlink" title="mini batch："></a>mini batch：</h4><p>1、batch训练，每次迭代都需要遍历整个训练集。理论上，代价函数是单调递减，若是出现增加，则必然有bug或者是一次运行的batch太大（运算时间很长）<br>2、mini batch训练，并不是每一次的迭代都是下降的，整体是单调递减，但会有很多噪声，出现噪音的原因是每个mini batch运算难度不一<br>3、当mini batch=1时，叫随机梯度下降法，每个样本都时独立的mini batch，每次运算都是局部最优，不一定朝着最小值方向，其代价函数永远不收敛，而是在最小值附件波动，缺点是失去所有向量化的运算加速、每次只计算一个会效率低。<br>4、通过减少学习率，噪声会有所减少<br>5、选择折中的mini batch大小，会有更快学习速度，既有向量化的运算加速，且不需要等待整个训练集被处理完就可以开始后续工作<br>6、若是训练集少于2000，直接使用batch会更好<br>7、一般mini batch大小：64、128、256、512，选择2的次方会更快</p><h4 id="指数加权平均（加权移动平均值-滑动平均）："><a href="#指数加权平均（加权移动平均值-滑动平均）：" class="headerlink" title="指数加权平均（加权移动平均值/滑动平均）："></a>指数加权平均（加权移动平均值/滑动平均）：</h4><p>1、Vt=βVt-1 + (1-β)θt     Vt==1/(1-β)<br>2、β=0.9，Vt==10，β=0.98，Vt==50，β=0.5，Vt==2<br>3、用于调整参数，选择中间值会得到更好的效果<br>4、指数加权平均运算占用内存少<br>5、指数加权平均往往比直接求平均数得到更好的估测，缺点是需要保存数据多</p><h4 id="bias-correction偏差修正："><a href="#bias-correction偏差修正：" class="headerlink" title="bias correction偏差修正："></a>bias correction偏差修正：</h4><p>1、偏差修正让平均数运算更加准确<br>2、β约靠近1，在估测初期，值会偏低，则不使用Vt，而使用Vt/(1-β^t)，可修复初期偏低情况</p><h4 id="Momentum梯度下降："><a href="#Momentum梯度下降：" class="headerlink" title="Momentum梯度下降："></a>Momentum梯度下降：</h4><p>1、学习率过大，会摆动过大<br>2、momentum使用指数加权平均数在每次梯度运算更新dw、db的值，会减少噪音（摆动）、更快更直接的到达最小值<br>3、Vdw = βVdw + (1-β)dw<br>​     Vdb = βVdb + (1-β)db<br>​     w = w - αVdw  b = b - αVdb<br>​     超参数：α(学习率)、β(指数加权平均数，常用0.9)<br>4、第二版：Vdw = βVdw + dw去掉了(1-β)，β仍然是0.9，α要相应改变，效果差不多，但更偏向上者</p><h4 id="RMSprop（root-mean-square-prop）均方根："><a href="#RMSprop（root-mean-square-prop）均方根：" class="headerlink" title="RMSprop（root mean square prop）均方根："></a>RMSprop（root mean square prop）均方根：</h4><p>1、与momentum类似，可以加速梯度下降<br>2、w决定水平方向（前进方向），b决定垂直方向（噪音、摆动方向），需要让减缓摆动，希望dw小一点使w更新后跟小，db大一点使b更新后变化不大，从而减少噪音。但需要一个较大的学习率α来加快学习<br>3、Sdw = βSdw + (1-β)(dw)^2<br>​     Sdb = βSdb + (1-β)(db)^2<br>​     w = w - αdw/(√Sdw)  b = b - αdb/(√Sdb)</p><h4 id="Adam优化算法-Adaptive-Moment-Estimation-Momentum-RMSprop"><a href="#Adam优化算法-Adaptive-Moment-Estimation-Momentum-RMSprop" class="headerlink" title="Adam优化算法(Adaptive Moment Estimation)=Momentum+RMSprop:"></a>Adam优化算法(Adaptive Moment Estimation)=Momentum+RMSprop:</h4><p>1、初始化Vdw=0，Sdw=0，Vdb=0，Sdb=0<br>​     t in loop(using mini batch)：<br>​            (momentum)<br>​        Vdw = β1Vdw + (1-β1)dw<br>​        Vdb = β1Vdb + (1-β1)db<br>​            (RMSprop)<br>​        Sdw = β2Sdw + (1-β2)(dw)^2<br>​        Sdb = β2Sdb + (1-β2)(db)^2<br>​           (bias correction)<br>​        Vdw = Vdw/(1-β1^t)    Vdb = Vdb/(1-β1^t)<br>​        Sdw = Sdw/(1-β2^t)    Sdb = Sdb/(1-β2^t)<br>​            (updata w&amp;b)<br>​        w = w - αVdw/(√(Sdw+ε))     b = b - αVdb/(√(Sdb+ε))   （debug α value，β1=0.9，β2=0.999，ε=10^-8(可不设置)）<br>2、结合momentum和RMSprop，适合更加广泛的神经网络</p><h4 id="Learning-rate-decay衰减学习率："><a href="#Learning-rate-decay衰减学习率：" class="headerlink" title="Learning rate decay衰减学习率："></a>Learning rate decay衰减学习率：</h4><p>1、随着训练递进，逐步慢慢减少学习率，从而加快学习速度（学习率过大无法收敛）<br>2、batch分成多个mini batch后，第一次遍历叫epoch1，epoch-num也表示遍历到第几个mini batch<br>3、α = α0/(1+decay-rate*epoch-num)<br>4、当α0=0.2，decay-rate=1时<br>​    epoch  α<br>​        1      0.1<br>​        2      0.67<br>​        3      0.5<br>​        4      0.4<br>5、学习率递减<br>6、指数衰减、离散下降学习率=每次下降减半、手动衰减</p><h4 id="局部最优："><a href="#局部最优：" class="headerlink" title="局部最优："></a>局部最优：</h4><p>1、通常梯度为0的点不是最优点<br>2、代价函数中的梯度为0的点叫鞍点<br>3、在高维度神经网络中，一般不会被困于较差的局部最优<br>4、图形平稳的的地方，会让学习十分缓慢（需要优化算法加速）</p><h4 id="调试处理："><a href="#调试处理：" class="headerlink" title="调试处理："></a>调试处理：</h4><p>1、调试先后重要程度：学习率α、momentum的β、mini batch 大小、隐含节点数、层数、衰减学习率<br>2、调参数之前不知到那个参数更重要，当选择两个参数时，若选择学习率alpha和adam的ε，α会相对更重要，ε取值变化不大，<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/1.PNG" alt="image"><br>3、若是在较优点附近的点效果也不错，则需要扩大这几个点范围，再次密集随机取点<br>4、在数轴上取值，随机均匀取样比较合理<br>5、学习率α范围在[0.0001,1]，选择在[10^a,10^b]内取值<br>6、β范围在[0.9,0.999]不好取值（0.9表示10个元素之间的平均，0.999表示1000个元素之间的平均），1-β范围在[0.001,0.1]容易取值，越靠近1取值变化会很大，若β在0.9到0.9005变化不大，而0.999到0.9995就相差很大</p><h4 id="batch归一化："><a href="#batch归一化：" class="headerlink" title="batch归一化："></a>batch归一化：</h4><p>1、归一化输入，可加快学习过程<br>2、在隐含节点中归一化的是z而不是激活函数后的a<br>3、batch归一化与mini batch一起用<br>4、batch归一化类似dropout带来一些噪音，有轻微正则化效果</p><h4 id="softmax分类："><a href="#softmax分类：" class="headerlink" title="softmax分类："></a>softmax分类：</h4><p>1、特点是将输出归一化，输入向量，输出向量</p><h4 id="ML策略："><a href="#ML策略：" class="headerlink" title="ML策略："></a>ML策略：</h4><p>当识别率为90%时，仍远远不够，需要<br>1）收集更多图片数据<br>2）收集更多样的训练数据集<br>3）使用梯度下降算法优化时，训练更长时间<br>4）使用Adam优化算法<br>5）设计一个更大或更小的神经网络<br>6）用dropout或L2正则化<br>7）修改网络框架（更换激活函数、改变隐含节点）</p><h4 id="正交化："><a href="#正交化：" class="headerlink" title="正交化："></a>正交化：</h4><p>1、可以调整的参数设置在不同的正交的维度上，调整其中一个参数，不会或几乎不会影响其他维度上的参数变化，更容易更快速地将参数调整到一个比较好的数值<br>2、若是在训练集表现不好，用更宽更深神经网络、用Adam优化算法<br>3、若是在验证集表现不好，可调节正则化、用更多训练数据<br>4、若是在测试集表现不好，用更多验证数据<br>5、若是在投入真实使用表现不好，需要修改代价函数J、验证集数据<br>6、测试集表现好坏与真实使用表现无关</p><h4 id="单一指数评估指标："><a href="#单一指数评估指标：" class="headerlink" title="单一指数评估指标："></a>单一指数评估指标：</h4><p>1、查准率（表示分类结果的百分比）查全率（表示分类结果对的所占百分比）两者之间往往需要折中<br>2、在查准率表现好的未必在查全率表现好<br>3、不能仅依靠查准率和查全率来选择训练好的分类器，F1 score是查准率P和查全率R的调和平均，更好去选择分类器<br>4、F1 score = 2/(1/P + 1/R)<br>5、当需要顾及多个指标，在观察多个成本大小时，选出最好的那个<br>6、测试集和验证集必须来自于同一分布，逼近同一目标<br>7、大数据时代，大量数据作为训练，少了量分给验证与测试<br>8、为了规避识别图片将情色图片识别进去目标图片范畴，给损失函数加个权重，限制情色图片（图片处理需要将情色图片具体标出来）原：J = 1/mΣL(y-yi)，修改后：J = 1/Σwi * ΣwiL(y-yi)<br>9、定义指标是为了选择出更好的分类器（1、如何定义一个指标衡量想做事情的表现；2、分开考虑如改善系统在指标上的表现）<br>10、当在测试集和验证集中表现好，在实际应用却不好，则需要修改指标，或者改变测试集</p><h4 id="机器学习与人对比："><a href="#机器学习与人对比：" class="headerlink" title="机器学习与人对比："></a>机器学习与人对比：</h4><p>1、通过大量数据训练，机器学习表现会出现超过人类，然后平稳，<span style="border-bottom:2px dashed red;">但始终会有一个性能无法超越的理论上限，叫贝叶斯最优误差Bayes optimal</span><br>2、将贝叶斯误差估计和训练误差之间的误差称为可避免偏差avoidable bias，训练误差与验证误差之间属于方差，哪个误差大就调整哪个<br>3、若训练集误差比贝叶斯误差还好，则是过拟合了<br>4、human-level performance人类水平表现，人类水平误差作为贝叶斯误差的代表<br>5、贝叶斯误差一般为小于0.5%<br>6、可避免偏差：更大模型、更优算法、训练更久、超参数搜索（找到更好神经网络架构）<br>7、方差：更多数据、正则化、dropout、数据增强、超参数搜索</p><h4 id="误差分析："><a href="#误差分析：" class="headerlink" title="误差分析："></a>误差分析：</h4><p>1、收集更多狗图片数据，喂入猫分类器，学习更多，以至于更好区别猫和狗<br>2、在错误分类中，找出问题较为严重的给予解决，抓住问题根本，例如照片模糊影响分类器比例比将狗识别为猫比例更大，应着手解决模糊问题<br>3、监督学习，在大量训练数据下，允许少量标记错误<br>4、验证数据做了修正，测试数据也需要做出同样的修正<br>5、同时检验算法判断正确和判断错误的例子，这才公平，否则对算法的偏差估计可能会变大</p><h4 id="语音识别："><a href="#语音识别：" class="headerlink" title="语音识别："></a>语音识别：</h4><p>1、背景噪音处理<br>2、口音处理<br>3、麦克风过远处理<br>4、儿童语音识别<br>5、口吃、感叹词处理</p><h4 id="神经网络创建准备："><a href="#神经网络创建准备：" class="headerlink" title="神经网络创建准备："></a>神经网络创建准备：</h4><p>1、设立验证集和测试集，还有指标<br>2、搭好机器学习系统原型，用训练集训练一下查看效果，理解算法的表现<br>3、<span style="border-bottom:2px dashed red;">用偏差和方差分析，决定优化方向</span><br>4、想出所有能走的方向，选择实际上最有希望的方向<br>5、若是搭载已成熟的方向，有大量论文理论支撑，可以直接搭载复杂的神经网络，例如人脸识别<br>6、若是新的方向，先由简单神经网络开始<br>7、主要是造出能用的神经网络模型，而不是<strong>发明全新的机器学习算法</strong></p><h4 id="训练集与测试集不是来自同一分布："><a href="#训练集与测试集不是来自同一分布：" class="headerlink" title="训练集与测试集不是来自同一分布："></a>训练集与测试集不是来自同一分布：</h4><p>1、option1：将来自不同分布的图片合并在一起（不推荐）<br>2、option2：若分布1是较多的，训练集=分布1+0.5×分布2，验证集=0.25×分部2，测试集=0.25×分部2<br>3、训练一个语音新方向的神经网络，使用已有语音识别的数据（音频剪辑、听写记录）和部分新方向的数据作为训练集，但验证集和测试集是新方向的数据</p><h4 id="不同分布数据集的偏差与方差："><a href="#不同分布数据集的偏差与方差：" class="headerlink" title="不同分布数据集的偏差与方差："></a>不同分布数据集的偏差与方差：</h4><p>1、训练集和验证集来自不同分布，会出现训练集误差很低，验证集误差相对较高<br>2、新成立数据集：training-dev set 训练验证集（来自于训练集，但不用于训练）<br>3、四部分数据集：训练集|训练验证集|验证集|测试集<br>​    贝叶斯误差：0%<br>​    训练误差：1%<br>​    训练验证误差：9%<br>​    验证误差：10%<br><strong>结论：方差问题！！！</strong><br>​    贝叶斯误差：0%<br>​    训练误差：1%<br>​    训练验证误差：1.5%<br>​    验证误差：10%<br><strong>结论：数据不匹配！！！</strong><br>​    贝叶斯误差：0%<br>​    训练误差：10%<br>​    训练验证误差：11%<br>​    验证误差：12%<br><strong>结论：偏差问题！！！</strong><br>​    贝叶斯误差：0%<br>​    训练误差：10%<br>​    训练验证误差：11%<br>​    验证误差：20%<br><strong>结论：可避免偏差相当高，数据不匹配！！！</strong><br>4、可避免偏差：贝叶斯误差与训练误差之间<br>​     方差：训练误差与训练验证误差<br>​     数据匹配程度：训练验证误差与验证误差<br>​     拟合程度：验证误差与测试误差<br>5、个别情况：验证误差和测试误差均小于训练误差和训练验证误差，是因为验证集数据更容易处理（两者不是同一分布）</p><h4 id="数据不匹配的优化尝试："><a href="#数据不匹配的优化尝试：" class="headerlink" title="数据不匹配的优化尝试："></a>数据不匹配的优化尝试：</h4><p>1、了解不同分布的数据集具体到差异，做误差分析，为避免过拟合，应该人工查看验证集而不是测试集<br>2、若在验证集中噪声可能更大，识别数字准确度不够，则需要收集更多类似验证集的数据去训练（降低数据不匹配，尽量来自于同一分布），或者去<span style="border-bottom:2px dashed red;">模拟噪声、模拟数字发音（将清晰的语音与噪声合成模拟现场的语音），在训练集做数据增强操作！（缺点：噪声也需要多样，否则容易过拟合）</span><br>3、”The quick brown fox jumps over the lazy dog”常在语音识别中出现，包含了26个字母<br>4、无人汽车中的汽车识别，运用人工合成的图片在人眼看来可能很正常，在只是合成了小情况的图片（无法将所有情况考虑进去），容易过拟合。（在渲染得十分逼真的游戏中，截图汽车的图片，但是游戏中汽车款式远少于现实生活中的汽车款式）</p><h4 id="迁移学习："><a href="#迁移学习：" class="headerlink" title="迁移学习："></a>迁移学习：</h4><p>1、将分类猫的神经网络所学习的知识，去学习关于x光图片识别的神经网络。将类似的神经网络学习称为迁移学习<br>2、神经网络框架基本不变，在最后一层输出需要改变成新的输出层<br>3、若是训练数据不多，则仅训练最后一层或两三层即可（节省时间，少数据重新训练可能会过拟合），其他隐含层就可以不训练，使用旧神经网络的参数<br>4、若是数据足够多，可以训练所有层参数<br>5、<span style="border-bottom:2px dashed red;">旧数据的初期训练阶段称为pre-training预训练，新图片数据训练阶段称为fine tuning微调</span><br>6、为什么旧的神经网络学习的东西能迁移到新的神经网络？因为<span style="border-bottom:2px dashed red;">旧神经网络已经学会低层次特征（边缘检测、曲线检测，阳性对象检测），已经学会了结构信息、图像形状信息，学会的点、线等等会帮助新神经网络的高层次特征学习</span><br>7、迁移学习意义是迁移来源问题（旧神经网络）有很多数据，但迁移目标问题（新神经网络）仅有少量数据（过少不足以拟合神经网络）<br>8、数据增强可用少数的图片数据变得更多，其中可以改变RGB通道的数值，改变颜色，使其失真；<br>9、若是仅对一种颜色进行改变，这叫PAC增强（Principle Components Analysis）</p><h4 id="multi-task-learning多任务学习："><a href="#multi-task-learning多任务学习：" class="headerlink" title="multi-task learning多任务学习："></a>multi-task learning多任务学习：</h4><p>1、迁移学习是类似神经网络的串行，多任务学习是类是类似神经网络的并行<br>2、<span style="border-bottom:2px dashed red;">无人汽车的同时执行多个物体的位置检测属于多任务学习</span>，单个神经网络系统中识别多个物体<br>3、单个神经网络识别多个物体比多个独立的神经网络分别识别物体性能更好<br>4、在训练数据中，一张图没有全部标记所需的物体，问题不大，输出结果是问号（不是0不是1），在求和中不会计算问号<br>5、意义：当识别多个物体能共用低层次特征；每个任务的数据量很接近（若有对称性，其他任务提供低层次特征，相对少量的数据也可以学习）；可以训练一个足够大的网络做好所有任务（不足够大的话，性能就比不上单独训练的神经网络）</p><h4 id="end-to-end-learning端到端学习："><a href="#end-to-end-learning端到端学习：" class="headerlink" title="end-to-end learning端到端学习："></a>end-to-end learning端到端学习：</h4><p>1、speech recognition语音识别：MFCC是用于在音频中提取一组特定的人工设计的特征，提取出低层次特征，组织成单词后串成transcript文本<br>2、端到端学习：只需要吧训练集拿过来直接学习到了x和y之间的函数映射，直接绕过其中很多的步骤，简化整个框架（需要大量数据才可以）（训练一个巨大神经网络，进输入音频即可得出文本，不从低层次特征学起）<br>3、face recognition人脸识别：若是用端到端学习，识别整个人一步到位输出身份信息，其实效果并不好（数据量足够的话，其实效率会更好）；若先识别整体人的脸部，裁剪使人脸居中再进行人脸识别会更好（分两部分解决问题都简单，而且数据量都多）<br>4、machine translation机器翻译：英法互译，在有很多数据能将单词一对一对应起来，端到端学习效率是很好<br>5、estimating child’s age估计孩子年龄：用x射线图估计孩子年龄，判断孩子发育是否正常（或者用于破案）。将照片中分割出每一块骨头，分别识别每块骨头应该属于哪里，查看长度，比对正常发育的长度比例，然后估计出孩子年龄（这种情况用端到端学习，效果就不好，没有足够多数据）<br>6、优点：1）只是让数据说话（足够多的x、y映射）（在传统对语音或图片的分割存在有人类的偏见，分割什么，怎么分，如何定义，都是人类创造的）（音频要分音位，图片要分像素，再用低层次特征组合高层次特征）2）省去很多神经网络中间手工组件的设计<br>7、缺点：1）需要大量x-y映射数据 2)省去中间的手工组件设计，也会排除掉一些有用的手工组件设计（机器学习工程师很鄙视手工设计，所以就无法从很小的训练集数据中获得洞察力）（学习知识来源是数据和手工设计）<br>8、<span style="border-bottom:2px dashed red;">用不用端到端学习，取决于是否有大量映射数据</span><br>9、无人驾驶：（深度学习）图像识别多个物体-（控制算法）规划路线，转盘方向-加速/减速指令</p><h4 id="卷积神经网络："><a href="#卷积神经网络：" class="headerlink" title="卷积神经网络："></a>卷积神经网络：</h4><p>1、image classification图像分类、object detection物体检测、neural style transfer 风格迁移<br>2、edge detection边缘检测，先将低层次特征的线条检测出来，再组合成高层次特征，最后组合成完整图像<br>3、conv kernel卷积核=filter过滤器，卷积convolve：元素相乘再求和<br>4、（垂直过滤器）卷积之后，检测到中间有线（6x6图片小，所以得出结果中间亮处线很粗）（若是由黑到亮的原图，结果线是黑色）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/2.png" alt="image"><br>5、sobel filter 增加了中间一行元素的权重，则处在图像中央的像素点，使结果的robust更高。<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/3.png" alt="image"><br>6、scharr filter也常用<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/4.png" alt="image"><br>7、也可以将filter所有元素设置为参数，用反向传播更新，得到更好filter，对复杂图像更好<br>8、输入图片nxn，过滤器fxf，结果为(n-f+1)x(n-f+1)<br>9、在没有padding情况下，角落的像素与中间的像素相比，中间像素被重复运算的几率更大，意味着丢掉了图像边缘位置信息<br>10、padding的意义：不是每次经过卷积层都需要缩小图片，否则在深层的神经网络中最后图片变得很小；保留边缘信息。<br>11、输入图片nxn，加入p圈的padding变成(n+p)x(n+p)，过滤器fxf，结果为(n+2p-f+1)x(n+2p-f+1)<br>12、padding加入多少圈有两个选择：valid卷积（no padding）、same卷积（输入输出一致，p=(f-1)/2(f一般为奇数，便于指出过滤器位置)）<br>13、输入图片nxn，padding为p，过滤器fxf，步长为s(s&gt;1)，结果为((n-f+1)/s + 1) x ((n-f+1)/s + 1)，不是整数，向下取整<br>14、在数学上，卷积运算前需要将过滤器沿着副对角线做镜像翻转，但在深度学习上没有翻转，仍称为卷积（convolution）；在机器学习上没有翻转，称为互相关（cross-correlation）<br>15、在rgb三通道的图片中，过滤器也需要是深度为3，同样元素相乘，三维的元素之和相加，最后结果是二维<br>16、当同时通过<strong>多种过滤器</strong>之后，所有<span style="border-bottom:2px dashed red;">二维结果堆叠在一起，形成三维</span><br>17、过滤器参数个数，fxfxnc（nc表示通道数，1或3），偏置1个（所有元素加相同一个数），n个过滤器，因此，个数=(fxfxnc+1)xn<br>18、过滤器参数个数不变，无论输入是多大的数据，输出都是固定的，有效避免过拟合<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/5.png" alt="image"><br>19、pooling池化用于缩小模型大小，提高计算速度，提高特征的robust （池化超参数是固定的，不需要梯度下降，计算公式与卷积计算公式一致，信道/深度不变）<br>20、常用最大池化，少用平均池化，也有在很深的神经网络时，会使用平均池化<br>21、常用池化大小为2x2，步长为2，等于原来高度宽度缩减一半；也常用3x3,步长为2的（其他大小就要具体看使用什么池化了，也可以加padding，但一般不加）<br>22、池化属于神经网络中的静态属性，是固定的<br>23、将卷积操作和池化操作一起称为卷积，属于一卷积层<br>24、尽量不要自己设置超级参数，查看文献采用超级参数数值<br>25、卷积层参数少于全连接层参数<br>26、激活值（参数数量）减少太快会影响神经网络性能<br>27、与全连接层相比，卷积层有两大优势：parameter sharing参数共享（在卷积操作时，卷积计算可以在不同图片区域使用不同的参数；一个过滤器适合一个图片某一块，则也会适合另一块）、sparsity connections稀疏连接（输入少），有着两个优势也可以预防过拟合<br>28、卷积神经网络善于捕捉trainslation invariance平移不变，即平移图片后，仍能识别成一个东西<br>29、损失函数等于神经网络对整个训练集的预测的损失总和，用梯度下降去减少误差<br>30、Alexnet比Lenet优势：使用了ReLU（Lenet使用的是sigmoid和tanh）、使用了两个GPU、使用LRN层（局部响应归一化）（后来被证实没啥用）<br>31、vgg16，没有太多参数，仅是一种只需要专注于构建卷积层的简单网络，优点是简化了神经网络结构（卷积核是3x3，步长1，same；过滤器2x2，步长2），卷积没有缩小图像（使用padding），仅在池化缩小图像。虽然参数非常巨大，神经网络很深，但是结构不复杂，比较规整<br>32、很深的神经网络很难训练，因为存在vanish梯度消失和exploding梯度爆炸的问题<br>33、使用1x1x1的过滤器，用在6x6x1图片上，效果不好，但用在6x6x32上，效果就很好（将深度上的元素做智能乘积运算）（被称为Network in Network）（用池化仅压缩高度和宽度，则1x1可以压缩/增加深度）（也可以不压缩深度，这就仅仅添加了非线性函数）<br>34、数据量多，则使用更少手工；数据量少（想低调，怕黑客攻击），则使用更多手工（可以获得更好表现 ），使用迁移学习更好<br>35、拥有大量数据，应花更多时间在设计神经网络框架中，手动工程则是十分困难；对于计算机视觉图片识别，计算机视觉文学依赖于大量手工工程<br>36、在基准做得好得技巧（在比赛用的多，在生产较少使用）：<br>​        Ensembling集成（独立训练几个神经网络（3-15个网络，耗时），再平均化输出，会再基准提升个1%、2%）<br>​        Multi-crop at test time（在图片分类中，从同一图片的多种不同视角进行识别（10-crop），平均输出）</p><h4 id="ResNet-残差网络（Residual-Network）："><a href="#ResNet-残差网络（Residual-Network）：" class="headerlink" title="ResNet 残差网络（Residual Network）："></a>ResNet 残差网络（Residual Network）：</h4><p>1、skip connection跳远链接，可从某一网络层获取激活，然后迅速反馈给另外一层，甚至是神经网络的更深层（有助于解决梯度消失和梯度爆炸问题）<br>2、Residual block残差块，ResNet是由残差块构建的<br>3、plain network 普通的神经网络，随着深度的增加，误差先是降低，然后升高；而ResNet深度增加，误差持续越少（几百层都可以）<br>4、<span style="border-bottom:2px dashed red;">在原有普通神经网络中，中间或末尾加入残缺块，性能不差于普通神经网络，更多时候能传递更多信息，性能更好（a[l+2]=g(z[l+2]+a[l])）</span><br>5、残缺块输入a[l]、输出a[l+2]的维度相同，若不同维度，则多加一个矩阵在a[l]前（a[l+2]=g(z[l+2]+w*a[l])）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/6.png" alt="image"></p><h4 id="Google-Inception-Net："><a href="#Google-Inception-Net：" class="headerlink" title="Google Inception Net："></a>Google Inception Net：</h4><p>1、Inception层的作用是代替人工来确定卷积层中的过滤器类型or是否要创建卷积层或者池化层（为了不让人做选择，则全部情况考虑进去）（缺点就是计算成本大）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/7.png" alt="image"><br>2、直接用5x5卷积运算，运算成本太大，每个元素计算1.2亿遍；<span style="border-bottom:2px dashed red;">在5x5卷积运算中间，加入一个1x1，将卷积运算分成两部卷积（先缩小再扩大）则可以降低计算成本，减少到原里1/10，1240万，1x1层被称为bottleneck layer瓶颈层</span><br>3、大幅缩小表示层规模，只要合理构建瓶颈层，就不会降低网络性能<br>4、单个inception模块<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/8.png" alt="image"><br>5、整体Inception Net<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/9.png" alt="image"><br>6、每个inception模块设计功能可以不一样，还可再Inception层分支出来做FC和softmax</p><h4 id="Object-Detection-对象检测："><a href="#Object-Detection-对象检测：" class="headerlink" title="Object Detection 对象检测："></a>Object Detection 对象检测：</h4><p>1、Image classification 图像分类，Classification with localization 分类定位，用图像分类的思路可以帮助学习分类定位，分类定位的思路又有助于学习对象检测<br>2、无人驾驶中需要检测的对象：pedestrian行人，car汽车、motorcycle摩托车、background背景<br>3、用bounding box边界框定位出目标，需要在神经网络多输出几个单元，输出边界框（就是让神经网络多数出四个数字bx、by、bh、bw用于定位）（<strong>图片左上角为(0,0)，右下角为(1,1)</strong>）<br>4、要想确定边界框的具体位置，需要指定红色方框的中心点(bx,by)，高度为bh，宽度为bw<br>5、<span style="border-bottom:2px dashed red;">在图片标签中，除了分类标签，还需要标签表示边框的四个数字（学习分类时，同时学习了边框）</span><br>6、一张图片的标签，pc表示分两类，pc=1时表示行人、汽车、摩托车（有对象类），pc=0时表示背景（没有对象），则y=[pc bx by  bh bw c1 c2 c3]（c1表示行人，c2表示汽车，c3表示摩托车）（暂时假定一张图至多有一个对象）（若一张图有汽车，则y=[1 bx by bh bw 0 1 0]，若一张背景图，则y=[0 ? ? ? ? ? ? ?]，?表示无意义的参数）（<strong>标签训练数据最终决定了训练结果</strong>）<br>7、损失值则等于一维矩阵中每个元素相应差值的平方和；若pc=1，损失值就是剩下元素的差值平方和；若pc=0，损失值是第一个元素差值平方和（后面7个元素无意义）<br>8、在实际运用上，<span style="border-bottom:2px dashed red;">pc应用logistic regression loss逻辑回归函数（squared error or predict平方预测误差也可以），边界框坐标应用平方误差（或其他类似方法），可以不对c1 c2 c3和softmax激活函数应用对数损失函数</span><br>9、<strong>Landmark detection 特征点检测</strong>，定义好多少个特征点，边界框四个，人脸64个，人体结构32个，均需要手工标注<br>10、对象检测采用的是基于<strong>sliding windows滑动窗口</strong>的目标检测算法（训练数据集，需要将汽车图片截图并标签）（先设定一个边界框，在图片开始滑动截图，以固定步幅滑动窗口，遍历图像的每个区域，每次都将截图喂入卷积神经网络，判断是否有对象）（计算成本高）（需要极小步幅滑动，才能准确定位图片中的对象）<br>11、在卷积神经网络上应用滑动窗口：首先将神经网络<span style="border-bottom:2px dashed red;">全连接层转化为卷积层</span><br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/10.png" alt="image"><br>设定边界框为14x14，在16x16图中进行滑动窗口卷积，得出4种结果，一次性输出在最终结果（而不是截取成4张图片再独立威入神经网络），在28x28图中滑动窗口卷积可以直接得出64种的所有结果（大大节省了计算成本，但仍然无法确定精准的边界）（与Fast R-CNN类似）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/11.png" alt="image"><br>12、<strong>YOLO(you only look once)算法</strong>：在100x100图片中分成3x3（实际操作可能会是19x19），<span style="border-bottom:2px dashed red;">九宫格中每个格子都要指定标签y=[pc bx by  bh bw c1 c2 c3]</span>，发现哪个格子有对象，则取对象的中点，然后将这个对象分配给包含对象中点的格子<span style="border-bottom:2px dashed red;">（如果有两个格子包含同一个对象，对象仅仅属于对象中点在的格子，对象仅仅属于一个格子，不能同时属于一个格子，对象中点是标签的(bx,by)）</span>，仅需要一次卷积就可输出3x3x8，九种情况，8个属性值。优点在于能输出精确的边界框，前提是每个格子不超过1个对象（将格子再细分）；速度快，可以达到实时识别<br>13、每个格子左上角都是(0,0)右下角都是(1,1)，bx、by的范围值在1之内，bh、bw可能会超过1<br>14、<strong>IoU(Intersection over union)交并比函数</strong>：用于判断对象检测算法运作是否良好。原理：计算预测的边界框和标签的边界框的交集和并集之比，最好情况是比值为1（范围是[0,1]）（约定只要IoU&gt;=0.5都认为正确（不过是人为定的，可以定0.6 0.7））<br>15、<strong>non-max supperession 非最大值抑制</strong>：在对象检测中，针对同一个对象都会做出多次检测，会得到多个预测边界框，非最大值抑制就是处理这些多个预测边界框（卷积神经网络后的结果，给出预测边界框的概率，选中最大概率的那一个，将其他的边界框与其做交并比，高度重叠、交并比很高的其他边界框全部被抑制显示）<br>16、对象检测整体流程：（yolo）将原图分成19x19个格子，通过卷积神经网络输出每个格子的情况，舍弃pc&lt;=0.6的格子，（非最大值抑制）剩下的边界框，仅保留最大pc值得边界框（若是检测对个对象，则独立进行多次非最大值抑制）<br>17、<strong>Anchor box</strong>：在一个格子中可以检测多个对象；定义多个不同形状anchor box，预测结果和这些anchor box关联起来（有时会达到5个anchor box甚至更多），对象会被分配有其中点的（格子，anchor box），原本卷积神经网络输出结果y只代表一个边界框，<span style="border-bottom:2px dashed red;">改为y中增加多个结果</span>（同时标签工作也需要将正确结果y标注清楚），<span style="border-bottom:2px dashed red;">anchor box最后就是非最大抑制后的边界框（缺点：要是仅定义两个anchor box，出现三个对象就不行了；出现两个一个类型的对象，也不行了</span>（但是用了19x19较细格子就很少出现该情况，两个对象中点出现在同一个格子概率很低））（手工选择anchor box必须考虑周全形状才可以）（通过机器学习的方法k-平均算法，可以自动选择一组anchor box，可以适合十几种对象）<br>18、当使用两个anchor box时，每个格子输出都会是有两个边界框，除去pc较低的边界框，在独立运行两次非最大值抑制即可得出最终的边界框<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/12.png" alt="image"><br>19、<strong>Region proposals（候选区域）R-CNN（带区域的卷积神经网络）</strong>：在滑动窗口卷积时，进选择一部分有意义的窗口进行卷积操作，减少卷积时间（但还是很慢）（候选区的方法时运行Segmentation algorithm 图像分割算法）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/13.png" alt="image"><br>20、<strong>Fast R-CNN</strong>：将全连接层转化为卷积层，一次卷积就可以得到所有滑动窗口的结果；<strong>Faster R-CNN</strong>：用卷积的方法选择候选区（比Fast R-CNN快，但没有YOLO快）</p><h4 id="Face-recognition-人脸识别："><a href="#Face-recognition-人脸识别：" class="headerlink" title="Face recognition 人脸识别："></a>Face recognition 人脸识别：</h4><p>1、<strong>Face Verification 人类验证</strong>：输入名字和相片，判断是否本人（1对1问题），而人脸识别是识别问题（1对多问题）<br>2、<strong>One-Shot 一步学习</strong>：只通过一张人脸图片，就能识别这个人；设计Similarity函数：直接对比两张图片，输出差异值（若是同一个人差异值很小，若不是同一个人，则差异值很大）<br>3、<strong>Siamese Network</strong>：在神经网络实现Similarity方法，训练一个Siamese网络，将图片喂入，得出结果是一个128维向量或者编码，用于代表这张图片，然后再d函数中实现对比两张图片向量或者编码的范数<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/14.png" alt="image"><br>4、<strong>Triple loss三元组损失</strong>：通过神经网络得到较优的人脸图片编码，其中一个方法是设计三元组损失函数，然后应用梯度下降（<span style="border-bottom:2px dashed red;">将原图定义为anchor图片，将是同一个人的图片称为positive，不是同一个人称为negative，同时对比三张图片，这就是三元(A,P,N)</span>）希望得到的结果是d(A,P)&lt;=d(A,N)，即是<strong>||f(A)-f(P)||2&lt;=||f(A)-f(N)||^2</strong>为了防止全部f(xi)输出0值，设置为<strong>||f(A)-f(P)||2-||f(A)-f(N)||2+α&lt;=0</strong>（α称为margin间隔）<br>5、基于三张图片来定义损失函数<strong>L(A,P,N) = Max(||f(A)-f(P)||2-||f(A)-f(N)||2+α, 0)</strong>（loss希望输出0，所以运用max函数）代价函数J  = ΣL(Ai, Pi, Ni)（需要将训练集分为三元组进行训练）（若是随机选择图片组合成三元组，很容易就满足<strong>d(A,P)+α&lt;=d(A,N)</strong>这个条件，尽量选择<strong>d(A,P)≈d(A,N)</strong>这种三元组训练才会让神经网络使d(A,P)更小、d(A,N)更大，否则梯度效果不好，识别也不好，神经网络就没学习到什么）<br>6、可以将人类识别转换为一个二分类问题，是同一个人输出1，不是则输出0（<strong>y = sigmoid(Σ wi*|f(xi)k-f(xj)k|+b)</strong>，用于预测1和0）</p><h4 id="Style-Transfer-风格迁移："><a href="#Style-Transfer-风格迁移：" class="headerlink" title="Style Transfer 风格迁移："></a>Style Transfer 风格迁移：</h4><p>1、神经网络学习已有大师的作品风格（Style）（S），将风格赋予给其他图片（Content）（C），形成同风格的新作品（Generated image）（G）<br>2、图像识别的神经网络：第一层都会去寻找低层次的图片特征（线条、颜色、阴影等）第二层识别的图片的质地，深层则会识别负责的图像<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/15.png" alt="image"><br>3、实现风格迁移，关键设计关于G的代价函数J(G)，衡量生成图片的好坏；分成两部分，第一部分是content cost内容代价J(C,G)（衡量原图C与生成图片G的相似程度），第二部分是style cost风格代价J(S,G)（衡量原风格S与生成图片G风格相似程度）<strong>J(G) = α Jcontent(C,G)+β Jstyle(S,G)</strong>（需要梯度下降不断更新G）<br><img src="https://github.com/soloistben/images/raw/master/deeplearning_image/16.png" alt="image"><br>4、<strong>Jcontent(C,G)[l] </strong>，用隐含层去计算内容代价，但不可以选择太浅网络（太浅的话生成图片仅是像素十分接近原图，深的神经网络会问是否有一只狗，然后生产图片肯定有只狗）（因此不能选太浅和太深）；用一个预训练的神经网络（可以是VGG）；分别给C、G设置激活数，a[i](C)和a[i](G)（若两激活数相似，则图片相似）<strong>Jcontent(C,G) = 1/2 ||a[i](C)-a[i](G)||^2</strong><br>5、<strong>Jstyle(S,G)</strong>，选择一层为图片风格定义一个深度测量，将图片风格定义为该层中各个通道之间激活项的相关系数（如何计算每个通道间的相关系数呢？）（<span style="border-bottom:2px dashed red;">若一通道识别纹理，一通道识别橙色，若是两通道相关关系大，则证明在出现纹理的地方颜色有很大概率是橙色</span>）（相关系数定义则是，两通道特征同时/不同时出现的概率）（对比原图S和生成图G的通道间相关系数之间的差距，就能判断风格是否相似）<br>6、设置激活项a[l](i,j,k)（i表示高度，j表示宽度，k表示通道数），定义一个Style Matrix（或者称为gram matrix）风格矩阵G[l](S)（大小为nc x nc，nc是该层通道数）（将k和k’通道相对应的激活项相乘求和，非标准的互相关函数（因为没有减去平均数）），<strong>G[l](S)kk’ = ΣiΣj a[l](i,j,k)a[l](i,j,k’)</strong>（俩激活项若是相关程度大，G值也大），原图S和生成图G都计算风格矩阵G[l](S)、G[l](G)，<strong>Jstyle(S,G)[l] = 1/(2*nh*nw*nc)2||G[l](S)kk’ - G[l](G)kk’||^2 = 1/(2*nh*nw*nc)^2ΣkΣk’(G[l](S)kk’ - G[l](G)kk’)^2</strong>，则<strong>Jstyle(S,G) = Σlλ[l]Jstyle(S,G)[l]</strong>（将每一层的相关系数求和）</p><h4 id="一维与三维图片的卷积"><a href="#一维与三维图片的卷积" class="headerlink" title="一维与三维图片的卷积:"></a>一维与三维图片的卷积:</h4><p>1、心电图或者信号图这种属于一维图片，ct片、x光片的3d立体扫描属于三维图片（电影也可属于三维，长、宽、时间轴，可以应用于检测动作和人物行为）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;激活函数：&quot;&gt;&lt;a href=&quot;#激活函数：&quot; class=&quot;headerlink&quot; title=&quot;激活函数：&quot;&gt;&lt;/a&gt;激活函数：&lt;/h4&gt;&lt;p&gt;1、sigmoid常用于二元分类在输出时做激活函数，其他地方tanh更优于sigmoid&lt;br&gt;2、tanh和sig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pandas_property</title>
    <link href="http://yoursite.com/2019/01/06/pandas-property/"/>
    <id>http://yoursite.com/2019/01/06/pandas-property/</id>
    <published>2019-01-06T13:45:48.000Z</published>
    <updated>2019-07-19T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="pandas属性"><a href="#pandas属性" class="headerlink" title="pandas属性"></a>pandas属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#自带下标</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#时间数组</span></span><br><span class="line">dates = pd.date_range(<span class="string">'20180106'</span>,periods=<span class="number">6</span>)</span><br><span class="line">print(dates)</span><br><span class="line"><span class="comment">#index是行索引，columns是列索引</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">print(df) </span><br><span class="line"><span class="comment">#默认索引</span></span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"><span class="comment">#字典dict</span></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>:<span class="number">1.</span>,</span><br><span class="line"><span class="string">'B'</span>:pd.Timestamp(<span class="string">'20180105'</span>),</span><br><span class="line"><span class="string">'C'</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line"><span class="string">'D'</span>:pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">"float32"</span>),</span><br><span class="line"><span class="string">'E'</span>:pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"solo"</span>,<span class="string">"lol"</span>]),</span><br><span class="line"><span class="string">"F"</span>:<span class="string">'cpp'</span>&#125;)</span><br><span class="line">print(df2)</span><br><span class="line">print(df2.dtypes)<span class="comment">#查看每列属性</span></span><br><span class="line">print(df2.index)<span class="comment">#查看行索引</span></span><br><span class="line">print(df2.columns)<span class="comment">#查看列索引</span></span><br><span class="line">print(df2.values)<span class="comment">#查看所有值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#描述(仅显示数字部分，数值、平均值、等等)</span></span><br><span class="line">print(df2.describe())</span><br><span class="line"><span class="comment">#转置</span></span><br><span class="line">print(df2.T)</span><br><span class="line"><span class="comment">#排序</span></span><br><span class="line">print(df2.sort_index(axis=<span class="number">1</span>,ascending=<span class="keyword">False</span>))<span class="comment">#列倒序排序</span></span><br><span class="line">print(df2.sort_index(axis=<span class="number">0</span>,ascending=<span class="keyword">False</span>))<span class="comment">#行倒序排序</span></span><br><span class="line"></span><br><span class="line">print(df2.sort_values(by=<span class="string">'E'</span>))<span class="comment">#值排序，根据'E'列排序(不写ascending的值，默认是true)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">0     1.0</span><br><span class="line">1     3.0</span><br><span class="line">2     6.0</span><br><span class="line">3     NaN</span><br><span class="line">4    44.0</span><br><span class="line">5     1.0</span><br><span class="line">dtype: float64</span><br><span class="line">DatetimeIndex([<span class="string">'2018-01-06'</span>, <span class="string">'2018-01-07'</span>, <span class="string">'2018-01-08'</span>, <span class="string">'2018-01-09'</span>,</span><br><span class="line">               <span class="string">'2018-01-10'</span>, <span class="string">'2018-01-11'</span>],</span><br><span class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</span><br><span class="line">                   a         b         c         d</span><br><span class="line">2018-01-06 -1.193238  1.729652  0.213075 -0.333416</span><br><span class="line">2018-01-07 -0.775480 -0.960333  0.349506  0.246139</span><br><span class="line">2018-01-08 -0.315293 -1.656652  0.504151  0.892104</span><br><span class="line">2018-01-09  1.111614 -0.210477  0.530345 -0.056502</span><br><span class="line">2018-01-10 -0.563181  0.870935  1.053737 -0.208736</span><br><span class="line">2018-01-11 -0.078093  0.722973 -0.939166  0.253624</span><br><span class="line"></span><br><span class="line">   0  1   2   3</span><br><span class="line">0  0  1   2   3</span><br><span class="line">1  4  5   6   7</span><br><span class="line">2  8  9  10  11</span><br><span class="line"></span><br><span class="line">     A          B  C    D      E    F</span><br><span class="line">0  1.0 2018-01-05  3  1.0   <span class="built_in">test</span>  cpp</span><br><span class="line">1  1.0 2018-01-05  3  1.0  train  cpp</span><br><span class="line">2  1.0 2018-01-05  3  1.0   solo  cpp</span><br><span class="line">3  1.0 2018-01-05  3  1.0    lol  cpp</span><br><span class="line"></span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C             int32</span><br><span class="line">D           float32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line"></span><br><span class="line">dtype: object</span><br><span class="line">Int64Index([0, 1, 2, 3], dtype=<span class="string">'int64'</span>)</span><br><span class="line">Index([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>], dtype=<span class="string">'object'</span>)</span><br><span class="line"></span><br><span class="line">[[1.0 Timestamp(<span class="string">'2018-01-05 00:00:00'</span>) 3 1.0 <span class="string">'test'</span> <span class="string">'cpp'</span>]</span><br><span class="line"> [1.0 Timestamp(<span class="string">'2018-01-05 00:00:00'</span>) 3 1.0 <span class="string">'train'</span> <span class="string">'cpp'</span>]</span><br><span class="line"> [1.0 Timestamp(<span class="string">'2018-01-05 00:00:00'</span>) 3 1.0 <span class="string">'solo'</span> <span class="string">'cpp'</span>]</span><br><span class="line"> [1.0 Timestamp(<span class="string">'2018-01-05 00:00:00'</span>) 3 1.0 <span class="string">'lol'</span> <span class="string">'cpp'</span>]]</span><br><span class="line">         A    C    D</span><br><span class="line">count  4.0  4.0  4.0</span><br><span class="line">mean   1.0  3.0  1.0</span><br><span class="line">std    0.0  0.0  0.0</span><br><span class="line">min    1.0  3.0  1.0</span><br><span class="line">25%    1.0  3.0  1.0</span><br><span class="line">50%    1.0  3.0  1.0</span><br><span class="line">75%    1.0  3.0  1.0</span><br><span class="line">max    1.0  3.0  1.0</span><br><span class="line"></span><br><span class="line">                     0         ...                             3</span><br><span class="line">A                    1         ...                             1</span><br><span class="line">B  2018-01-05 00:00:00         ...           2018-01-05 00:00:00</span><br><span class="line">C                    3         ...                             3</span><br><span class="line">D                    1         ...                             1</span><br><span class="line">E                 <span class="built_in">test</span>         ...                           lol</span><br><span class="line">F                  cpp         ...                           cpp</span><br><span class="line">[6 rows x 4 columns]</span><br><span class="line"></span><br><span class="line">     F      E    D  C          B    A</span><br><span class="line">0  cpp   <span class="built_in">test</span>  1.0  3 2018-01-05  1.0</span><br><span class="line">1  cpp  train  1.0  3 2018-01-05  1.0</span><br><span class="line">2  cpp   solo  1.0  3 2018-01-05  1.0</span><br><span class="line">3  cpp    lol  1.0  3 2018-01-05  1.0</span><br><span class="line">     A          B  C    D      E    F</span><br><span class="line">3  1.0 2018-01-05  3  1.0    lol  cpp</span><br><span class="line">2  1.0 2018-01-05  3  1.0   solo  cpp</span><br><span class="line">1  1.0 2018-01-05  3  1.0  train  cpp</span><br><span class="line">0  1.0 2018-01-05  3  1.0   <span class="built_in">test</span>  cpp</span><br><span class="line">     A          B  C    D      E    F</span><br><span class="line">3  1.0 2018-01-05  3  1.0    lol  cpp</span><br><span class="line">2  1.0 2018-01-05  3  1.0   solo  cpp</span><br><span class="line">0  1.0 2018-01-05  3  1.0   <span class="built_in">test</span>  cpp</span><br><span class="line">1  1.0 2018-01-05  3  1.0  train  cpp</span><br></pre></td></tr></table></figure><hr><h4 id="选择数据"><a href="#选择数据" class="headerlink" title="选择数据"></a>选择数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">dates = pd.date_range(<span class="string">'20180106'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(df[<span class="string">'A'</span>])</span><br><span class="line">print(df.A)<span class="comment">#显示第A列</span></span><br><span class="line">print(df[<span class="number">0</span>:<span class="number">2</span>])<span class="comment">#前两行</span></span><br><span class="line">print(df[<span class="string">'20180107'</span>:<span class="string">'20180109'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#select by label:loc</span></span><br><span class="line">print(df.loc[<span class="string">'20180108'</span>])</span><br><span class="line">print(df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]])<span class="comment">#A,B列的所有行</span></span><br><span class="line">print(df.loc[<span class="string">'20180108'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]])<span class="comment">#A,B列的20180108行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#select by position:iloc</span></span><br><span class="line">print(df.iloc[<span class="number">3</span>])<span class="comment">#第4行数据</span></span><br><span class="line">print(df.iloc[<span class="number">3</span>,<span class="number">1</span>])<span class="comment">#第4行第2个元素</span></span><br><span class="line">print(df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#第4行-第5行的第3列和第4列数据</span></span><br><span class="line">print(df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#第2行--第4行-第6行的第3列和第5列数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mixed selection:in 混合标签和索引筛选</span></span><br><span class="line">print(df.ix[:<span class="number">3</span>,[<span class="string">'A'</span>,<span class="string">'C'</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#boolean indexing</span></span><br><span class="line">print(df[df.A&gt;<span class="number">8</span>])<span class="comment">#A列大于8的所有行</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">             A   B   C   D</span><br><span class="line">2018-01-06   0   1   2   3</span><br><span class="line">2018-01-07   4   5   6   7</span><br><span class="line">2018-01-08   8   9  10  11</span><br><span class="line">2018-01-09  12  13  14  15</span><br><span class="line">2018-01-10  16  17  18  19</span><br><span class="line">2018-01-11  20  21  22  23</span><br><span class="line">2018-01-06     0</span><br><span class="line">2018-01-07     4</span><br><span class="line">2018-01-08     8</span><br><span class="line">2018-01-09    12</span><br><span class="line">2018-01-10    16</span><br><span class="line">2018-01-11    20</span><br><span class="line">Freq: D, Name: A, dtype: int32</span><br><span class="line">2018-01-06     0</span><br><span class="line">2018-01-07     4</span><br><span class="line">2018-01-08     8</span><br><span class="line">2018-01-09    12</span><br><span class="line">2018-01-10    16</span><br><span class="line">2018-01-11    20</span><br><span class="line">Freq: D, Name: A, dtype: int32</span><br><span class="line">            A  B  C  D</span><br><span class="line">2018-01-06  0  1  2  3</span><br><span class="line">2018-01-07  4  5  6  7</span><br><span class="line">             A   B   C   D</span><br><span class="line">2018-01-07   4   5   6   7</span><br><span class="line">2018-01-08   8   9  10  11</span><br><span class="line">2018-01-09  12  13  14  15</span><br><span class="line">A     8</span><br><span class="line">B     9</span><br><span class="line">C    10</span><br><span class="line">D    11</span><br><span class="line">Name: 2018-01-08 00:00:00, dtype: int32</span><br><span class="line">             A   B</span><br><span class="line">2018-01-06   0   1</span><br><span class="line">2018-01-07   4   5</span><br><span class="line">2018-01-08   8   9</span><br><span class="line">2018-01-09  12  13</span><br><span class="line">2018-01-10  16  17</span><br><span class="line">2018-01-11  20  21</span><br><span class="line">A    8</span><br><span class="line">B    9</span><br><span class="line">Name: 2018-01-08 00:00:00, dtype: int32</span><br><span class="line">A    12</span><br><span class="line">B    13</span><br><span class="line">C    14</span><br><span class="line">D    15</span><br><span class="line">Name: 2018-01-09 00:00:00, dtype: int32</span><br><span class="line">13</span><br><span class="line">             C   D</span><br><span class="line">2018-01-09  14  15</span><br><span class="line">2018-01-10  18  19</span><br><span class="line">             C   D</span><br><span class="line">2018-01-07   6   7</span><br><span class="line">2018-01-09  14  15</span><br><span class="line">2018-01-11  22  23</span><br><span class="line">            A   C</span><br><span class="line">2018-01-06  0   2</span><br><span class="line">2018-01-07  4   6</span><br><span class="line">2018-01-08  8  10</span><br><span class="line">             A   B   C   D</span><br><span class="line">2018-01-09  12  13  14  15</span><br><span class="line">2018-01-10  16  17  18  19</span><br><span class="line">2018-01-11  20  21  22  23</span><br></pre></td></tr></table></figure><hr><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">2</span>,<span class="number">2</span>] = <span class="number">111</span></span><br><span class="line">df.loc[<span class="string">'20130101'</span>,<span class="string">'B'</span>] = <span class="number">222</span></span><br><span class="line">print(df.A&gt;<span class="number">12</span>)</span><br><span class="line">df[df.A&gt;<span class="number">12</span>] = <span class="number">0</span><span class="comment">#df.A大于12的每一行全置0</span></span><br><span class="line">print(df)</span><br><span class="line">df.A[df.A&lt;<span class="number">12</span>] = <span class="number">1</span><span class="comment">#df.A大于12的每一行的A列全置1</span></span><br><span class="line">print(df)</span><br><span class="line">df[<span class="string">'F'</span>] = np.nan<span class="comment">#添加多1列</span></span><br><span class="line">print(df)</span><br><span class="line">df[<span class="string">'E'</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],index=pd.date_range(<span class="string">'20130101'</span>,periods=<span class="number">6</span>))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">             A   B   C   D</span><br><span class="line">2013-01-01   0   1   2   3</span><br><span class="line">2013-01-02   4   5   6   7</span><br><span class="line">2013-01-03   8   9  10  11</span><br><span class="line">2013-01-04  12  13  14  15</span><br><span class="line">2013-01-05  16  17  18  19</span><br><span class="line">2013-01-06  20  21  22  23</span><br><span class="line"></span><br><span class="line">2013-01-01    False</span><br><span class="line">2013-01-02    False</span><br><span class="line">2013-01-03    False</span><br><span class="line">2013-01-04    False</span><br><span class="line">2013-01-05     True</span><br><span class="line">2013-01-06     True</span><br><span class="line">Freq: D, Name: A, dtype: bool</span><br><span class="line"></span><br><span class="line">             A    B    C   D</span><br><span class="line">2013-01-01   0  222    2   3</span><br><span class="line">2013-01-02   4    5    6   7</span><br><span class="line">2013-01-03   8    9  111  11</span><br><span class="line">2013-01-04  12   13   14  15</span><br><span class="line">2013-01-05   0    0    0   0</span><br><span class="line">2013-01-06   0    0    0   0</span><br><span class="line"></span><br><span class="line">             A    B    C   D</span><br><span class="line">2013-01-01   1  222    2   3</span><br><span class="line">2013-01-02   1    5    6   7</span><br><span class="line">2013-01-03   1    9  111  11</span><br><span class="line">2013-01-04  12   13   14  15</span><br><span class="line">2013-01-05   1    0    0   0</span><br><span class="line">2013-01-06   1    0    0   0</span><br><span class="line"></span><br><span class="line">             A    B    C   D   F</span><br><span class="line">2013-01-01   1  222    2   3 NaN</span><br><span class="line">2013-01-02   1    5    6   7 NaN</span><br><span class="line">2013-01-03   1    9  111  11 NaN</span><br><span class="line">2013-01-04  12   13   14  15 NaN</span><br><span class="line">2013-01-05   1    0    0   0 NaN</span><br><span class="line">2013-01-06   1    0    0   0 NaN</span><br><span class="line"></span><br><span class="line">             A    B    C   D   F  E</span><br><span class="line">2013-01-01   1  222    2   3 NaN  1</span><br><span class="line">2013-01-02   1    5    6   7 NaN  2</span><br><span class="line">2013-01-03   1    9  111  11 NaN  3</span><br><span class="line">2013-01-04  12   13   14  15 NaN  4</span><br><span class="line">2013-01-05   1    0    0   0 NaN  5</span><br><span class="line">2013-01-06   1    0    0   0 NaN  6</span><br></pre></td></tr></table></figure><hr><h4 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#处理丢失数据</span></span><br><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>] = np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = np.nan</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#how&#123;'any','all'&#125;,any表示只要出现NaN数据就丢弃,all表示全部是NaN才丢弃</span></span><br><span class="line"><span class="comment">#axis 0表示行，1表示列</span></span><br><span class="line">print(df.dropna(axis=<span class="number">1</span>,how=<span class="string">'any'</span>))</span><br><span class="line"><span class="comment">#填补NaN</span></span><br><span class="line">print(df.fillna(value=<span class="number">0</span>))<span class="comment">#填补完后还是缺失状态</span></span><br><span class="line"><span class="comment">#是否有NaN</span></span><br><span class="line">print(df.isnull())<span class="comment">#返回矩阵</span></span><br><span class="line">print(np.any(df.isnull())==<span class="keyword">True</span>)<span class="comment">#返回是否有缺失</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">             A     B     C   D</span><br><span class="line">2013-01-01   0   NaN   2.0   3</span><br><span class="line">2013-01-02   4   5.0   NaN   7</span><br><span class="line">2013-01-03   8   9.0  10.0  11</span><br><span class="line">2013-01-04  12  13.0  14.0  15</span><br><span class="line">2013-01-05  16  17.0  18.0  19</span><br><span class="line">2013-01-06  20  21.0  22.0  23</span><br><span class="line">             A   D</span><br><span class="line">2013-01-01   0   3</span><br><span class="line">2013-01-02   4   7</span><br><span class="line">2013-01-03   8  11</span><br><span class="line">2013-01-04  12  15</span><br><span class="line">2013-01-05  16  19</span><br><span class="line">2013-01-06  20  23</span><br><span class="line">             A     B     C   D</span><br><span class="line">2013-01-01   0   0.0   2.0   3</span><br><span class="line">2013-01-02   4   5.0   0.0   7</span><br><span class="line">2013-01-03   8   9.0  10.0  11</span><br><span class="line">2013-01-04  12  13.0  14.0  15</span><br><span class="line">2013-01-05  16  17.0  18.0  19</span><br><span class="line">2013-01-06  20  21.0  22.0  23</span><br><span class="line">                A      B      C      D</span><br><span class="line">2013-01-01  False   True  False  False</span><br><span class="line">2013-01-02  False  False   True  False</span><br><span class="line">2013-01-03  False  False  False  False</span><br><span class="line">2013-01-04  False  False  False  False</span><br><span class="line">2013-01-05  False  False  False  False</span><br><span class="line">2013-01-06  False  False  False  False</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><hr><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#读取存取 数据</span></span><br><span class="line"><span class="comment">#read_csv(excel最基础格式,也可以读取txt，推荐)#to_csv</span></span><br><span class="line"><span class="comment">#read_excel#to_excel</span></span><br><span class="line"><span class="comment">#read_hdf#to_hdf</span></span><br><span class="line"><span class="comment">#read_sql#to_sql</span></span><br><span class="line"><span class="comment">#read_json#to_json</span></span><br><span class="line"><span class="comment">#read_msgpack#to_msgpack</span></span><br><span class="line"><span class="comment">#read_html#to_html</span></span><br><span class="line"><span class="comment">#read_gdp#to_gdp</span></span><br><span class="line"><span class="comment">#read_stata#to_stata</span></span><br><span class="line"><span class="comment">#read_sas#to_sas</span></span><br><span class="line"><span class="comment">#read_clipboard#to_clipboard</span></span><br><span class="line"><span class="comment">#read_pickle(python)#to_pickle(python)</span></span><br><span class="line">data = pd.read_csv(<span class="string">'stu.csv'</span>)</span><br><span class="line">print(data)</span><br><span class="line">data.to_pickle(<span class="string">'stu.pickle'</span>)</span><br><span class="line">data.to_json(<span class="string">'stu.json'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    Student ID   name  age  gender</span><br><span class="line">0         1100  Kelly   22  Female</span><br><span class="line">1         1101    Clo   21  Female</span><br><span class="line">2         1102  Tilly   22  Female</span><br><span class="line">3         1103   Tony   24    Male</span><br><span class="line">4         1104  David   20    Male</span><br><span class="line">5         1105  Catty   22  Female</span><br><span class="line">6         1106      M    3  Female</span><br><span class="line">7         1107      N   43    Male</span><br><span class="line">8         1108      A   13    Male</span><br><span class="line">9         1109      S   12    Male</span><br><span class="line">10        1110  David   33    Male</span><br><span class="line">11        1111     Dw    3  Female</span><br><span class="line">12        1112      Q   23    Male</span><br><span class="line">13        1113      W   21  Female</span><br></pre></td></tr></table></figure><hr><h4 id="矩阵合并-简单-concat"><a href="#矩阵合并-简单-concat" class="headerlink" title="矩阵合并 (简单)concat"></a>矩阵合并 (简单)concat</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment">#concatenating  合并dataframe</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line">print(df3)</span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>,ignore_index=<span class="keyword">True</span>)<span class="comment">#竖向合并,ignore_index 重新排序</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#join,['inner','outer']</span></span><br><span class="line">df4 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df5 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(df4)</span><br><span class="line">print(df5)</span><br><span class="line">res1 = pd.concat([df4,df5],join=<span class="string">'inner'</span>,ignore_index=<span class="keyword">True</span>)<span class="comment">#将不匹配的去掉</span></span><br><span class="line">print(res1)</span><br><span class="line">res2 = pd.concat([df4,df5],join=<span class="string">'outer'</span>,ignore_index=<span class="keyword">True</span>)</span><br><span class="line">print(res2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#join_axes</span></span><br><span class="line">res3 = pd.concat([df4,df5],axis=<span class="number">1</span>,join_axes=[df4.index])<span class="comment">#引用df4的index，df5没有的用NaN代替，多余的去除</span></span><br><span class="line">print(res3)</span><br><span class="line"><span class="comment">#append</span></span><br><span class="line">df6 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df7 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df8 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">res4 = df6.append(df7,ignore_index=<span class="keyword">True</span>)</span><br><span class="line">res5 = df6.append([df7,df8],ignore_index=<span class="keyword">True</span>)</span><br><span class="line">print(res4)</span><br><span class="line">print(res5)</span><br><span class="line">s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])<span class="comment">#仅添加加一行</span></span><br><span class="line">res6 = df6.append(s1,ignore_index=<span class="keyword">True</span>)</span><br><span class="line">print(res6)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#concat</span></span><br><span class="line">     a    b    c    d</span><br><span class="line">0  0.0  0.0  0.0  0.0</span><br><span class="line">1  0.0  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0  0.0</span><br><span class="line">     a    b    c    d</span><br><span class="line">0  1.0  1.0  1.0  1.0</span><br><span class="line">1  1.0  1.0  1.0  1.0</span><br><span class="line">2  1.0  1.0  1.0  1.0</span><br><span class="line">     a    b    c    d</span><br><span class="line">0  2.0  2.0  2.0  2.0</span><br><span class="line">1  2.0  2.0  2.0  2.0</span><br><span class="line">2  2.0  2.0  2.0  2.0</span><br><span class="line">     a    b    c    d</span><br><span class="line">0  0.0  0.0  0.0  0.0</span><br><span class="line">1  0.0  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0  0.0</span><br><span class="line">3  1.0  1.0  1.0  1.0</span><br><span class="line">4  1.0  1.0  1.0  1.0</span><br><span class="line">5  1.0  1.0  1.0  1.0</span><br><span class="line">6  2.0  2.0  2.0  2.0</span><br><span class="line">7  2.0  2.0  2.0  2.0</span><br><span class="line">8  2.0  2.0  2.0  2.0</span><br><span class="line"><span class="comment">#join</span></span><br><span class="line">     a    b    c    d</span><br><span class="line">1  0.0  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0  0.0</span><br><span class="line">3  0.0  0.0  0.0  0.0</span><br><span class="line">     b    c    d    e</span><br><span class="line">2  1.0  1.0  1.0  1.0</span><br><span class="line">3  1.0  1.0  1.0  1.0</span><br><span class="line">4  1.0  1.0  1.0  1.0</span><br><span class="line">     b    c    d</span><br><span class="line">0  0.0  0.0  0.0</span><br><span class="line">1  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0</span><br><span class="line">3  1.0  1.0  1.0</span><br><span class="line">4  1.0  1.0  1.0</span><br><span class="line">5  1.0  1.0  1.0</span><br><span class="line">     a    b    c    d    e</span><br><span class="line">0  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">1  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">2  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">3  NaN  1.0  1.0  1.0  1.0</span><br><span class="line">4  NaN  1.0  1.0  1.0  1.0</span><br><span class="line">5  NaN  1.0  1.0  1.0  1.0</span><br><span class="line"><span class="comment">#join_axes</span></span><br><span class="line">     a    b    c    d    b    c    d    e</span><br><span class="line">1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span><br><span class="line">2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line">3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line"><span class="comment">#append</span></span><br><span class="line">     a    b    c    d</span><br><span class="line">0  0.0  0.0  0.0  0.0</span><br><span class="line">1  0.0  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0  0.0</span><br><span class="line">3  1.0  1.0  1.0  1.0</span><br><span class="line">4  1.0  1.0  1.0  1.0</span><br><span class="line">5  1.0  1.0  1.0  1.0</span><br><span class="line">     a    b    c    d    e</span><br><span class="line">0  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">1  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">2  0.0  0.0  0.0  0.0  NaN</span><br><span class="line">3  1.0  1.0  1.0  1.0  NaN</span><br><span class="line">4  1.0  1.0  1.0  1.0  NaN</span><br><span class="line">5  1.0  1.0  1.0  1.0  NaN</span><br><span class="line">6  NaN  2.0  2.0  2.0  2.0</span><br><span class="line">7  NaN  2.0  2.0  2.0  2.0</span><br><span class="line">8  NaN  2.0  2.0  2.0  2.0</span><br><span class="line">     a    b    c    d</span><br><span class="line">0  0.0  0.0  0.0  0.0</span><br><span class="line">1  0.0  0.0  0.0  0.0</span><br><span class="line">2  0.0  0.0  0.0  0.0</span><br><span class="line">3  1.0  2.0  3.0  4.0</span><br></pre></td></tr></table></figure><hr><h4 id="矩阵合并-merge"><a href="#矩阵合并-merge" class="headerlink" title="矩阵合并 merge"></a>矩阵合并 merge</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#Merge</span></span><br><span class="line"><span class="comment">#merging two df by key/keys.(may be used in database)</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line"><span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line"><span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line"><span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line"><span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>]&#125;)</span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line">res = pd.merge(left,right,on=<span class="string">'key'</span>)<span class="comment">#基于key合并</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2列key</span></span><br><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>],</span><br><span class="line"><span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K0'</span>,<span class="string">'K1'</span>],</span><br><span class="line"><span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line"><span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>]&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>],</span><br><span class="line"><span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K0'</span>],</span><br><span class="line"><span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line"><span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>]&#125;)</span><br><span class="line">print(left1)</span><br><span class="line">print(right1)</span><br><span class="line">res = pd.merge(left1,right1,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>])<span class="comment">#默认inner</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#how = ['left','right','inner','outer']</span></span><br><span class="line">res = pd.merge(left1,right1,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'outer'</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = pd.merge(left1,right1,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'left'</span>)<span class="comment">#基于left填充</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># indicator显示提示合并方式</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_left'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line">res = pd.merge(df1,df2,on=<span class="string">'col1'</span>,how=<span class="string">'outer'</span>,indicator=<span class="keyword">True</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = pd.merge(df1,df2,on=<span class="string">'col1'</span>,how=<span class="string">'outer'</span>,indicator=<span class="string">'in_col'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#index</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>],</span><br><span class="line"><span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>]&#125;,</span><br><span class="line">index=[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>])</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line"><span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>]&#125;,</span><br><span class="line">index=[<span class="string">'K0'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>])</span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line">res = pd.merge(left,right,left_index=<span class="keyword">True</span>,right_index=<span class="keyword">True</span>,how=<span class="string">'outer'</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = pd.merge(left,right,left_index=<span class="keyword">True</span>,right_index=<span class="keyword">True</span>,how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overlapping</span></span><br><span class="line">boys = pd.DataFrame(&#123;<span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>],<span class="string">'age'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span><br><span class="line">girls = pd.DataFrame(&#123;<span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K3'</span>],<span class="string">'age'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;)</span><br><span class="line">print(boys)</span><br><span class="line">print(girls)</span><br><span class="line"><span class="comment">#suffixes用于区分</span></span><br><span class="line">res = pd.merge(boys,girls,on=<span class="string">'k'</span>,suffixes=[<span class="string">'_boy'</span>,<span class="string">'_girl'</span>],how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#join与merge类似</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Merge</span></span><br><span class="line">  key   A   B</span><br><span class="line">0  K0  A0  B0</span><br><span class="line">1  K1  A1  B1</span><br><span class="line">2  K2  A2  B2</span><br><span class="line">3  K3  A3  B3</span><br><span class="line">  key   C   D</span><br><span class="line">0  K0  C0  D0</span><br><span class="line">1  K1  C1  D1</span><br><span class="line">2  K2  C2  D2</span><br><span class="line">3  K3  C3  D3</span><br><span class="line">  key   A   B   C   D</span><br><span class="line">0  K0  A0  B0  C0  D0</span><br><span class="line">1  K1  A1  B1  C1  D1</span><br><span class="line">2  K2  A2  B2  C2  D2</span><br><span class="line">3  K3  A3  B3  C3  D3</span><br><span class="line"><span class="comment"># 2列key</span></span><br><span class="line">  key1 key2   A   B</span><br><span class="line">0   K0   K0  A0  B0</span><br><span class="line">1   K0   K1  A1  B1</span><br><span class="line">2   K1   K0  A2  B2</span><br><span class="line">3   K2   K1  A3  B3</span><br><span class="line">  key1 key2   C   D</span><br><span class="line">0   K0   K0  C0  D0</span><br><span class="line">1   K1   K0  C1  D1</span><br><span class="line">2   K1   K0  C2  D2</span><br><span class="line">3   K2   K0  C3  D3</span><br><span class="line">  key1 key2   A   B   C   D</span><br><span class="line">0   K0   K0  A0  B0  C0  D0</span><br><span class="line">1   K1   K0  A2  B2  C1  D1</span><br><span class="line">2   K1   K0  A2  B2  C2  D2</span><br><span class="line">  key1 key2    A    B    C    D</span><br><span class="line">0   K0   K0   A0   B0   C0   D0</span><br><span class="line">1   K0   K1   A1   B1  NaN  NaN</span><br><span class="line">2   K1   K0   A2   B2   C1   D1</span><br><span class="line">3   K1   K0   A2   B2   C2   D2</span><br><span class="line">4   K2   K1   A3   B3  NaN  NaN</span><br><span class="line">5   K2   K0  NaN  NaN   C3   D3</span><br><span class="line">  key1 key2   A   B    C    D</span><br><span class="line">0   K0   K0  A0  B0   C0   D0</span><br><span class="line">1   K0   K1  A1  B1  NaN  NaN</span><br><span class="line">2   K1   K0  A2  B2   C1   D1</span><br><span class="line">3   K1   K0  A2  B2   C2   D2</span><br><span class="line">4   K2   K1  A3  B3  NaN  NaN</span><br><span class="line"><span class="comment"># indicator显示提示合并方式</span></span><br><span class="line">   col1 col_left</span><br><span class="line">0     0        a</span><br><span class="line">1     1        b</span><br><span class="line">   col1  col_left</span><br><span class="line">0     1         2</span><br><span class="line">1     2         2</span><br><span class="line">2     2         2</span><br><span class="line">   col1 col_left_x  col_left_y      _merge</span><br><span class="line">0     0          a         NaN   left_only</span><br><span class="line">1     1          b         2.0        both</span><br><span class="line">2     2        NaN         2.0  right_only</span><br><span class="line">3     2        NaN         2.0  right_only</span><br><span class="line">   col1 col_left_x  col_left_y      in_col</span><br><span class="line">0     0          a         NaN   left_only</span><br><span class="line">1     1          b         2.0        both</span><br><span class="line">2     2        NaN         2.0  right_only</span><br><span class="line">3     2        NaN         2.0  right_only</span><br><span class="line"><span class="comment">#index</span></span><br><span class="line">     A   B</span><br><span class="line">K0  A0  B0</span><br><span class="line">K1  A1  B1</span><br><span class="line">K2  A2  B2</span><br><span class="line">     C   D</span><br><span class="line">K0  C0  D0</span><br><span class="line">K2  C2  D2</span><br><span class="line">K3  C3  D3</span><br><span class="line">      A    B    C    D</span><br><span class="line">K0   A0   B0   C0   D0</span><br><span class="line">K1   A1   B1  NaN  NaN</span><br><span class="line">K2   A2   B2   C2   D2</span><br><span class="line">K3  NaN  NaN   C3   D3</span><br><span class="line">     A   B   C   D</span><br><span class="line">K0  A0  B0  C0  D0</span><br><span class="line">K2  A2  B2  C2  D2</span><br><span class="line"><span class="comment">#overlapping</span></span><br><span class="line">    k  age</span><br><span class="line">0  K0    1</span><br><span class="line">1  K1    2</span><br><span class="line">2  K2    3</span><br><span class="line">    k  age</span><br><span class="line">0  K0    4</span><br><span class="line">1  K0    5</span><br><span class="line">2  K3    6</span><br><span class="line">    k  age_boy  age_girl</span><br><span class="line">0  K0        1         4</span><br><span class="line">1  K0        1         5</span><br></pre></td></tr></table></figure><hr><h4 id="可视化-plot"><a href="#可视化-plot" class="headerlink" title="可视化 plot"></a>可视化 plot</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="comment">#plot data</span></span><br><span class="line"><span class="comment">#Series</span></span><br><span class="line">data = pd.Series(np.random.randn(<span class="number">1000</span>),index=np.arange(<span class="number">1000</span>))</span><br><span class="line"><span class="comment">#DataFrame</span></span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>),<span class="comment">#4个属性</span></span><br><span class="line">index=np.arange(<span class="number">1000</span>),</span><br><span class="line">columns=list(<span class="string">"ABCD"</span>))</span><br><span class="line"></span><br><span class="line">print(data.head())<span class="comment">#显示前五个数据，默认是5</span></span><br><span class="line">data = data.cumsum()<span class="comment">#累加</span></span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment">#plot methods</span></span><br><span class="line"><span class="comment">#'bar','hist','box','kde','area','scatter','pie','hexbin'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ax = data.plot.scatter(x='A',y='B',color='DarkBlue',label='Class 1')#两个属性</span></span><br><span class="line"><span class="comment"># data.plot.scatter(x='A',y='C',color='DarkGreen',label='Class 2',ax=ax)#ax=ax,表示在一张图打印两张数据</span></span><br><span class="line">plt.showr</span><br></pre></td></tr></table></figure><p><img src="https://github.com/soloistben/images/raw/master/pandas_image/1.PNG" alt="series"><br><img src="https://github.com/soloistben/images/raw/master/pandas_image/2.PNG" alt="dataframe"><br><img src="https://github.com/soloistben/images/raw/master/pandas_image/3.PNG" alt="scatter"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;pandas属性&quot;&gt;&lt;a href=&quot;#pandas属性&quot; class=&quot;headerlink&quot; title=&quot;pandas属性&quot;&gt;&lt;/a&gt;pandas属性&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>octave_property</title>
    <link href="http://yoursite.com/2019/01/05/octave-property/"/>
    <id>http://yoursite.com/2019/01/05/octave-property/</id>
    <published>2019-01-05T15:52:11.000Z</published>
    <updated>2019-07-19T03:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1）基本操作"><a href="#1）基本操作" class="headerlink" title="1）基本操作"></a>1）基本操作</h3><h4 id="加减乘除、等、不等、注释、与、或、异或"><a href="#加减乘除、等、不等、注释、与、或、异或" class="headerlink" title="加减乘除、等、不等、注释、与、或、异或"></a>加减乘除、等、不等、注释、与、或、异或</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/1.jpg" alt="image" title="基本操作"></p><h4 id="直接输出（不加分号）、加分号阻止输出（形成变量）、类似C一样限制输出变量、格式变换"><a href="#直接输出（不加分号）、加分号阻止输出（形成变量）、类似C一样限制输出变量、格式变换" class="headerlink" title="直接输出（不加分号）、加分号阻止输出（形成变量）、类似C一样限制输出变量、格式变换"></a>直接输出（不加分号）、加分号阻止输出（形成变量）、类似C一样限制输出变量、格式变换</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/2.jpg" alt="image"></p><h4 id="普通矩阵"><a href="#普通矩阵" class="headerlink" title="普通矩阵"></a>普通矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/3.jpg" alt="image"></p><h4 id="行、列矩阵"><a href="#行、列矩阵" class="headerlink" title="行、列矩阵"></a>行、列矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/4.jpg" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/5.jpg" alt="image"></p><h4 id="全1矩阵"><a href="#全1矩阵" class="headerlink" title="全1矩阵"></a>全1矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/6.jpg" alt="image"></p><h4 id="全0矩阵"><a href="#全0矩阵" class="headerlink" title="全0矩阵"></a>全0矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/7.jpg" alt="image"></p><h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/8.jpg" alt="image"></p><h4 id="随机矩阵"><a href="#随机矩阵" class="headerlink" title="随机矩阵"></a>随机矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/9.jpg" alt="image"></p><h4 id="服从高斯分布的随机矩阵"><a href="#服从高斯分布的随机矩阵" class="headerlink" title="服从高斯分布的随机矩阵"></a>服从高斯分布的随机矩阵</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/10.jpg" alt="image"></p><h4 id="范围值（中间可添加增量）"><a href="#范围值（中间可添加增量）" class="headerlink" title="范围值（中间可添加增量）"></a>范围值（中间可添加增量）</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/11.jpg" alt="image"></p><h4 id="高斯分布直方图"><a href="#高斯分布直方图" class="headerlink" title="高斯分布直方图"></a>高斯分布直方图</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/12.jpg" alt="image"></p><h5 id="help-命令（查看命令使用）"><a href="#help-命令（查看命令使用）" class="headerlink" title="help + 命令（查看命令使用）"></a>help + 命令（查看命令使用）</h5><h3 id="2）数据移动操作"><a href="#2）数据移动操作" class="headerlink" title="2）数据移动操作"></a>2）数据移动操作</h3><h5 id="size-A-（返回矩阵类型，几行几列，也是一个1-2的一维矩阵）"><a href="#size-A-（返回矩阵类型，几行几列，也是一个1-2的一维矩阵）" class="headerlink" title="size(A)（返回矩阵类型，几行几列，也是一个1*2的一维矩阵）"></a>size(A)（返回矩阵类型，几行几列，也是一个1*2的一维矩阵）</h5><h5 id="size-A-1-（返回矩阵A的行数）"><a href="#size-A-1-（返回矩阵A的行数）" class="headerlink" title="size(A,1)（返回矩阵A的行数）"></a>size(A,1)（返回矩阵A的行数）</h5><h5 id="length-A-（返回矩阵A的行数）"><a href="#length-A-（返回矩阵A的行数）" class="headerlink" title="length(A)（返回矩阵A的行数）"></a>length(A)（返回矩阵A的行数）</h5><h5 id="load-xx-dat（加载当前目录的xx-dat文件数据，其xx为变量名称，文件数据为变量值，用于存取矩阵数据）"><a href="#load-xx-dat（加载当前目录的xx-dat文件数据，其xx为变量名称，文件数据为变量值，用于存取矩阵数据）" class="headerlink" title="load xx.dat（加载当前目录的xx.dat文件数据，其xx为变量名称，文件数据为变量值，用于存取矩阵数据）"></a>load xx.dat（加载当前目录的xx.dat文件数据，其xx为变量名称，文件数据为变量值，用于存取矩阵数据）</h5><h5 id="who（显示当前已有变量）"><a href="#who（显示当前已有变量）" class="headerlink" title="who（显示当前已有变量）"></a>who（显示当前已有变量）</h5><h5 id="whos（显示当前已有变量详情）"><a href="#whos（显示当前已有变量详情）" class="headerlink" title="whos（显示当前已有变量详情）"></a>whos（显示当前已有变量详情）</h5><h5 id="clear-xx（清除变量）"><a href="#clear-xx（清除变量）" class="headerlink" title="clear xx（清除变量）"></a>clear xx（清除变量）</h5><h5 id="v-priceY-1-10-（将priceY的前十个元素赋值给v，前提priceY有这么多或更多的数据）"><a href="#v-priceY-1-10-（将priceY的前十个元素赋值给v，前提priceY有这么多或更多的数据）" class="headerlink" title="v = priceY(1,10);（将priceY的前十个元素赋值给v，前提priceY有这么多或更多的数据）"></a>v = priceY(1,10);（将priceY的前十个元素赋值给v，前提priceY有这么多或更多的数据）</h5><h5 id="save-vv-mat-v（将v变量的内容保存在本地vv-mat文件中）"><a href="#save-vv-mat-v（将v变量的内容保存在本地vv-mat文件中）" class="headerlink" title="save vv.mat v（将v变量的内容保存在本地vv.mat文件中）"></a>save vv.mat v（将v变量的内容保存在本地vv.mat文件中）</h5><h5 id="save-vv-txt-v-ascii（以ascii形式保存数据）"><a href="#save-vv-txt-v-ascii（以ascii形式保存数据）" class="headerlink" title="save vv.txt v -ascii（以ascii形式保存数据）"></a>save vv.txt v -ascii（以ascii形式保存数据）</h5><h5 id="clear（会清除所以变量）"><a href="#clear（会清除所以变量）" class="headerlink" title="clear（会清除所以变量）"></a>clear（会清除所以变量）</h5><h5 id="load-vv-mat（会将文件内容恢复到原有变量中，即使原因变量被清除也会新建同名变量）"><a href="#load-vv-mat（会将文件内容恢复到原有变量中，即使原因变量被清除也会新建同名变量）" class="headerlink" title="load vv.mat（会将文件内容恢复到原有变量中，即使原因变量被清除也会新建同名变量）"></a>load vv.mat（会将文件内容恢复到原有变量中，即使原因变量被清除也会新建同名变量）</h5><h5 id="A-2-3-（A矩阵中的-行为2列为3位置的元素）"><a href="#A-2-3-（A矩阵中的-行为2列为3位置的元素）" class="headerlink" title="A(2,3)（A矩阵中的 行为2列为3位置的元素）"></a>A(2,3)（A矩阵中的 行为2列为3位置的元素）</h5><h5 id="A-2-（第2行的所有元素）"><a href="#A-2-（第2行的所有元素）" class="headerlink" title="A(2,:)（第2行的所有元素）"></a>A(2,:)（第2行的所有元素）</h5><h5 id="A-2-（第2列的所有元素）"><a href="#A-2-（第2列的所有元素）" class="headerlink" title="A(:,2)（第2列的所有元素）"></a>A(:,2)（第2列的所有元素）</h5><h5 id="A-1-3-（第1和第三行的所有元素）"><a href="#A-1-3-（第1和第三行的所有元素）" class="headerlink" title="A([1 3],:)（第1和第三行的所有元素）"></a>A([1 3],:)（第1和第三行的所有元素）</h5><h5 id="A-2-1-2-3-（A矩阵第2列直接赋值-1-2-3-，前提行列大小符合）"><a href="#A-2-1-2-3-（A矩阵第2列直接赋值-1-2-3-，前提行列大小符合）" class="headerlink" title="A(:,2)=[1;2;3]（A矩阵第2列直接赋值[1;2;3]，前提行列大小符合）"></a>A(:,2)=[1;2;3]（A矩阵第2列直接赋值[1;2;3]，前提行列大小符合）</h5><h5 id="A-A-1-2-3-（在原矩阵中多添加一列-1-2-3-）"><a href="#A-A-1-2-3-（在原矩阵中多添加一列-1-2-3-）" class="headerlink" title="A=[A,[1;2;3;]]（在原矩阵中多添加一列[1;2;3]）"></a>A=[A,[1;2;3;]]（在原矩阵中多添加一列[1;2;3]）</h5><h5 id="A-（将3x3的A矩阵转成9x1列向量一样输出）"><a href="#A-（将3x3的A矩阵转成9x1列向量一样输出）" class="headerlink" title="A(:)（将3x3的A矩阵转成9x1列向量一样输出）"></a>A(:)（将3x3的A矩阵转成9x1列向量一样输出）</h5><h5 id="C-A-B-（将A-B矩阵上下组合成C）"><a href="#C-A-B-（将A-B矩阵上下组合成C）" class="headerlink" title="C=[A;B]（将A,B矩阵上下组合成C）"></a>C=[A;B]（将A,B矩阵上下组合成C）</h5><h5 id="C-A-B-（将A-B矩阵左右组合成C）"><a href="#C-A-B-（将A-B矩阵左右组合成C）" class="headerlink" title="C=[A B]（将A,B矩阵左右组合成C）"></a>C=[A B]（将A,B矩阵左右组合成C）</h5><h5 id="（矩阵中-A-B-等价于-A-B-）"><a href="#（矩阵中-A-B-等价于-A-B-）" class="headerlink" title="（矩阵中[A B]等价于[A,B]）"></a>（矩阵中[A B]等价于[A,B]）</h5><h3 id="3）数据计算操作"><a href="#3）数据计算操作" class="headerlink" title="3）数据计算操作"></a>3）数据计算操作</h3><h5 id="A-B（A与B矩阵对应相乘）"><a href="#A-B（A与B矩阵对应相乘）" class="headerlink" title="A.*B（A与B矩阵对应相乘）"></a>A.*B（A与B矩阵对应相乘）</h5><h5 id="A-2（A矩阵元素平方）"><a href="#A-2（A矩阵元素平方）" class="headerlink" title="A.^2（A矩阵元素平方）"></a>A.^2（A矩阵元素平方）</h5><h5 id="1-A（A矩阵元素倒数）"><a href="#1-A（A矩阵元素倒数）" class="headerlink" title="1./A（A矩阵元素倒数）"></a>1./A（A矩阵元素倒数）</h5><h5 id="log-A-（对数运算）"><a href="#log-A-（对数运算）" class="headerlink" title="log(A) （对数运算）"></a>log(A) （对数运算）</h5><h5 id="exp-A-（指数运算）"><a href="#exp-A-（指数运算）" class="headerlink" title="exp(A)（指数运算）"></a>exp(A)（指数运算）</h5><h5 id="abs-A-（绝对值运算）"><a href="#abs-A-（绝对值运算）" class="headerlink" title="abs(A)（绝对值运算）"></a>abs(A)（绝对值运算）</h5><h5 id="A（取相反数）"><a href="#A（取相反数）" class="headerlink" title="-A（取相反数）"></a>-A（取相反数）</h5><h5 id="v-1（列向量v全部元素加1）等价于-v-ones-length-v-1"><a href="#v-1（列向量v全部元素加1）等价于-v-ones-length-v-1" class="headerlink" title="v+1（列向量v全部元素加1）等价于 v+ones(length(v),1)"></a>v+1（列向量v全部元素加1）等价于 v+ones(length(v),1)</h5><h5 id="A’（A的转置）"><a href="#A’（A的转置）" class="headerlink" title="A’（A的转置）"></a>A’（A的转置）</h5><h5 id="pinv-A-（A的逆）"><a href="#pinv-A-（A的逆）" class="headerlink" title="pinv(A)（A的逆）"></a>pinv(A)（A的逆）</h5><h4 id="sum求和、prod求积、floor向下取整、ceil向上取整"><a href="#sum求和、prod求积、floor向下取整、ceil向上取整" class="headerlink" title="sum求和、prod求积、floor向下取整、ceil向上取整"></a>sum求和、prod求积、floor向下取整、ceil向上取整</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/13.jpg" alt="image"></p><h5 id="sum-A-1-（元素列和）"><a href="#sum-A-1-（元素列和）" class="headerlink" title="sum(A,1)（元素列和）"></a>sum(A,1)（元素列和）</h5><h5 id="sum-A-2-（元素行和）"><a href="#sum-A-2-（元素行和）" class="headerlink" title="sum(A,2)（元素行和）"></a>sum(A,2)（元素行和）</h5><h5 id="sum-sum-A-eye-length-A-（求对角线和，eye是单位阵，前提A为方阵）"><a href="#sum-sum-A-eye-length-A-（求对角线和，eye是单位阵，前提A为方阵）" class="headerlink" title="sum(sum(A.*eye(length(A))（求对角线和，eye是单位阵，前提A为方阵）"></a>sum(sum(A.*eye(length(A))（求对角线和，eye是单位阵，前提A为方阵）</h5><h5 id="flipud-eye-3-（3阶单位矩阵的副对角线为1）"><a href="#flipud-eye-3-（3阶单位矩阵的副对角线为1）" class="headerlink" title="flipud(eye(3))（3阶单位矩阵的副对角线为1）"></a>flipud(eye(3))（3阶单位矩阵的副对角线为1）</h5><h5 id="max-v-（列向量v的最大值）"><a href="#max-v-（列向量v的最大值）" class="headerlink" title="max(v)（列向量v的最大值）"></a>max(v)（列向量v的最大值）</h5><h5 id="val-ins-max-v-（列向量v最大的两个值分别赋值）"><a href="#val-ins-max-v-（列向量v最大的两个值分别赋值）" class="headerlink" title="[val,ins]=max(v)（列向量v最大的两个值分别赋值）"></a>[val,ins]=max(v)（列向量v最大的两个值分别赋值）</h5><h5 id="max-A-（返回每一列的最大元素，组成一维向量组）"><a href="#max-A-（返回每一列的最大元素，组成一维向量组）" class="headerlink" title="max(A)（返回每一列的最大元素，组成一维向量组）"></a>max(A)（返回每一列的最大元素，组成一维向量组）</h5><h5 id="max-max-A-或者max-A-（将形成的一维向量中再找最大值）"><a href="#max-max-A-或者max-A-（将形成的一维向量中再找最大值）" class="headerlink" title="max(max(A))或者max(A(:))（将形成的一维向量中再找最大值）"></a>max(max(A))或者max(A(:))（将形成的一维向量中再找最大值）</h5><p><img src="https://github.com/soloistben/images/raw/master/octave_image/14.jpg" alt="image"></p><h5 id="（1代表找到每一列的最大值，2代表找没一行的最大值）"><a href="#（1代表找到每一列的最大值，2代表找没一行的最大值）" class="headerlink" title="（1代表找到每一列的最大值，2代表找没一行的最大值）"></a>（1代表找到每一列的最大值，2代表找没一行的最大值）</h5><p><img src="https://github.com/soloistben/images/raw/master/octave_image/15.jpg" alt="image"></p><h5 id="v-lt-3（返回一个与v相同类型的矩阵，元素对应的是1和0，1代表true该位置的v的元素比3小）"><a href="#v-lt-3（返回一个与v相同类型的矩阵，元素对应的是1和0，1代表true该位置的v的元素比3小）" class="headerlink" title="v&lt;3（返回一个与v相同类型的矩阵，元素对应的是1和0，1代表true该位置的v的元素比3小）"></a>v&lt;3（返回一个与v相同类型的矩阵，元素对应的是1和0，1代表true该位置的v的元素比3小）</h5><h5 id="find-v-lt-3-（返回比3小的元素下标）"><a href="#find-v-lt-3-（返回比3小的元素下标）" class="headerlink" title="find(v&lt;3) （返回比3小的元素下标）"></a>find(v&lt;3) （返回比3小的元素下标）</h5><h5 id="r-c-find-A-lt-3-（r返回行下标，c返回列下标）"><a href="#r-c-find-A-lt-3-（r返回行下标，c返回列下标）" class="headerlink" title="[r,c]=find(A&lt;3)（r返回行下标，c返回列下标）"></a>[r,c]=find(A&lt;3)（r返回行下标，c返回列下标）</h5><h5 id="magic-3-（返回一个3x3矩阵，行和-列和-对角线和，机器学习基本不用）"><a href="#magic-3-（返回一个3x3矩阵，行和-列和-对角线和，机器学习基本不用）" class="headerlink" title="magic(3)（返回一个3x3矩阵，行和=列和=对角线和，机器学习基本不用）"></a>magic(3)（返回一个3x3矩阵，行和=列和=对角线和，机器学习基本不用）</h5><h3 id="4）数据可视化"><a href="#4）数据可视化" class="headerlink" title="4）数据可视化"></a>4）数据可视化</h3><h4 id="输出函数图像"><a href="#输出函数图像" class="headerlink" title="输出函数图像"></a>输出函数图像</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/16.PNG" alt="image"></p><h4 id="两函数图象在同一坐标中"><a href="#两函数图象在同一坐标中" class="headerlink" title="两函数图象在同一坐标中"></a>两函数图象在同一坐标中</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/17.PNG" alt="image"></p><h4 id="分开输出"><a href="#分开输出" class="headerlink" title="分开输出"></a>分开输出</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/18.PNG" alt="image"></p><h4 id="左右输出"><a href="#左右输出" class="headerlink" title="左右输出"></a>左右输出</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/19.PNG" alt="image"></p><h4 id="改变坐标系"><a href="#改变坐标系" class="headerlink" title="改变坐标系"></a>改变坐标系</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/20.PNG" alt="image"></p><h4 id="添加横纵坐标名称、title名称、保存数据图"><a href="#添加横纵坐标名称、title名称、保存数据图" class="headerlink" title="添加横纵坐标名称、title名称、保存数据图"></a>添加横纵坐标名称、title名称、保存数据图</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/21.PNG" alt="image"></p><h4 id="矩阵输出图像"><a href="#矩阵输出图像" class="headerlink" title="矩阵输出图像"></a>矩阵输出图像</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/22.PNG" alt="image"><br><img src="https://github.com/soloistben/images/raw/master/octave_image/23.png" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/24.png" alt="image"></p><h3 id="5）基础函数使用"><a href="#5）基础函数使用" class="headerlink" title="5）基础函数使用"></a>5）基础函数使用</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/25.PNG" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/26.PNG" alt="image"></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/27.PNG" alt="image"></p><h4 id="break操作"><a href="#break操作" class="headerlink" title="break操作"></a>break操作</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/28.PNG" alt="image"></p><h4 id="if操作"><a href="#if操作" class="headerlink" title="if操作"></a>if操作</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/29.PNG" alt="image"></p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h4 id="​-在当前目录下建立xxx-m文件"><a href="#​-在当前目录下建立xxx-m文件" class="headerlink" title="​    在当前目录下建立xxx.m文件"></a>​    在当前目录下建立xxx.m文件</h4><h4 id="则xxx是函数名称"><a href="#则xxx是函数名称" class="headerlink" title="则xxx是函数名称"></a>则xxx是函数名称</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/30.PNG" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/31.PNG" alt="image"></p><h4 id="函数可返回多个值"><a href="#函数可返回多个值" class="headerlink" title="函数可返回多个值"></a>函数可返回多个值</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/32.PNG" alt="image"><br><img src="https://github.com/soloistben/images/raw/master/octave_image/33.PNG" alt="image"></p><h4 id="复杂函数"><a href="#复杂函数" class="headerlink" title="复杂函数"></a>复杂函数</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/34.PNG" alt="image"><br><img src="https://github.com/soloistben/images/raw/master/octave_image/35.PNG" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/36.PNG" alt="image"> </p><h3 id="6）函数向量化"><a href="#6）函数向量化" class="headerlink" title="6）函数向量化"></a>6）函数向量化</h3><h4 id="循环的数组-gt-一维行或列向量"><a href="#循环的数组-gt-一维行或列向量" class="headerlink" title="循环的数组 =&gt; 一维行或列向量"></a>循环的数组 =&gt; 一维行或列向量</h4><p><img src="https://github.com/soloistben/images/raw/master/octave_image/37.PNG" alt="image"> <img src="https://github.com/soloistben/images/raw/master/octave_image/38.PNG" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1）基本操作&quot;&gt;&lt;a href=&quot;#1）基本操作&quot; class=&quot;headerlink&quot; title=&quot;1）基本操作&quot;&gt;&lt;/a&gt;1）基本操作&lt;/h3&gt;&lt;h4 id=&quot;加减乘除、等、不等、注释、与、或、异或&quot;&gt;&lt;a href=&quot;#加减乘除、等、不等、注释、与、或、异
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>numpy_property</title>
    <link href="http://yoursite.com/2019/01/05/numpy-property/"/>
    <id>http://yoursite.com/2019/01/05/numpy-property/</id>
    <published>2019-01-05T15:12:27.000Z</published>
    <updated>2019-01-06T06:53:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="numpy-属性"><a href="#numpy-属性" class="headerlink" title="numpy 属性"></a>numpy 属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'number of dim:'</span>,a.ndim)      <span class="comment">#维度</span></span><br><span class="line">print(<span class="string">'shape:'</span>,a.shape)     <span class="comment">#矩阵类型</span></span><br><span class="line">print(<span class="string">'size:'</span>,a.size)</span><br><span class="line"></span><br><span class="line">a1 = np.array([<span class="number">2</span>,<span class="number">23</span>,<span class="number">4</span>],dtype=np.float64)    <span class="comment">#不同类型数组</span></span><br><span class="line">print(<span class="string">'a1_type:'</span>,a1.dtype)</span><br><span class="line"></span><br><span class="line">z = np.zeros((<span class="number">4</span>,<span class="number">3</span>))<span class="comment">#零矩阵</span></span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">o = np.ones((<span class="number">3</span>,<span class="number">4</span>),dtype=np.int16)<span class="comment">#全1矩阵</span></span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">e = np.empty((<span class="number">3</span>,<span class="number">2</span>))<span class="comment">#空矩阵</span></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">e1 = np.eye(<span class="number">3</span>)<span class="comment">#单位矩阵</span></span><br><span class="line">print(e1)</span><br><span class="line"></span><br><span class="line">l = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)  <span class="comment">#3是间距</span></span><br><span class="line">print(l)</span><br><span class="line">ll = np.arange(<span class="number">10</span>)</span><br><span class="line">print(ll)</span><br><span class="line">lll = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))<span class="comment">#重组成对应矩阵</span></span><br><span class="line">print(lll)</span><br><span class="line"></span><br><span class="line">lis = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)   <span class="comment">#生成线段</span></span><br><span class="line">print(lis)</span><br><span class="line">lis1 = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">#生成线段矩阵</span></span><br><span class="line">print(lis1)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">number of dim: 2</span><br><span class="line">shape: (2, 3)</span><br><span class="line">size: 6</span><br><span class="line">a1_type: float64</span><br><span class="line"></span><br><span class="line">[[ 0.  0.  0.]</span><br><span class="line"> [ 0.  0.  0.]</span><br><span class="line"> [ 0.  0.  0.]</span><br><span class="line"> [ 0.  0.  0.]]</span><br><span class="line">[[1 1 1 1]</span><br><span class="line"> [1 1 1 1]</span><br><span class="line"> [1 1 1 1]]</span><br><span class="line">[[  2.67276450e+185   1.69506143e+190]</span><br><span class="line"> [  1.75184137e+190   9.48819320e+077]</span><br><span class="line"> [  1.63730399e-306   0.00000000e+000]]</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br><span class="line"> </span><br><span class="line">[10 13 16 19]</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line"> </span><br><span class="line">[  1.     3.25   5.5    7.75  10.  ]</span><br><span class="line">[[  1.    2.8   4.6]</span><br><span class="line"> [  6.4   8.2  10. ]]</span><br></pre></td></tr></table></figure><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一维</span></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(<span class="string">'a:'</span>,a,<span class="string">'b:'</span>,b)</span><br><span class="line">c = a-b     <span class="comment">#加减一样操作</span></span><br><span class="line">print(<span class="string">'c=a-b:'</span>,c)</span><br><span class="line">d = b**<span class="number">2</span>    <span class="comment">#b的平方</span></span><br><span class="line">print(<span class="string">'d=b^2:'</span>,d)</span><br><span class="line">s = <span class="number">10</span>*np.sin(a)</span><br><span class="line">print(<span class="string">'s=10*sin(a):'</span>,s)</span><br><span class="line">print(<span class="string">'b&lt;3:'</span>,b&lt;<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'b==3:'</span>,b==<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a: [10 20 30 40] b: [1 2 3 4]</span><br><span class="line">c=a-b: [ 9 18 27 36]</span><br><span class="line">d=b^2: [ 1  4  9 16]</span><br><span class="line">s=10*sin(a): [-5.44021111  9.12945251 -9.88031624  7.4511316 ]</span><br><span class="line">b&lt;3: [ True  True False False]</span><br><span class="line">b==3: [False False  True False]</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多维</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = a*b     <span class="comment">#逐个相乘</span></span><br><span class="line">c_dot = np.dot(a,b)     <span class="comment">#矩阵相乘</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line">print(<span class="string">'c=a*b:\n'</span>,c)</span><br><span class="line">print(<span class="string">'c_dot=np.dot(a,b):\n'</span>,c_dot)</span><br><span class="line">print(<span class="string">'c_dot = np.dot(a,b):\n'</span>,c_dot_2)</span><br><span class="line"></span><br><span class="line">arr = np.random.random((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">'sum:'</span>,np.sum(arr))</span><br><span class="line">print(<span class="string">'sum_row:'</span>,np.sum(arr,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">'sum_col:'</span>,np.sum(arr,axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">'min:'</span>,np.min(arr))</span><br><span class="line">print(<span class="string">'max:'</span>,np.max(arr))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[1 1]</span><br><span class="line"> [1 0]]</span><br><span class="line">[[0 1]</span><br><span class="line"> [2 3]]</span><br><span class="line">c=a*b: </span><br><span class="line">[[0 1]</span><br><span class="line"> [2 0]]</span><br><span class="line">c_dot=np.dot(a,b): </span><br><span class="line">[[2 4]</span><br><span class="line"> [0 1]]</span><br><span class="line">c_dot = np.dot(a,b):   </span><br><span class="line">[[2 4]</span><br><span class="line"> [0 1]]</span><br><span class="line">[[ 0.65500072  0.70859584]</span><br><span class="line"> [ 0.70246984  0.07589378]</span><br><span class="line"> [ 0.05927354  0.67936378]]</span><br><span class="line">sum: 2.88059749371</span><br><span class="line">sum_row: [ 1.4167441  1.4638534]</span><br><span class="line">sum_col: [ 1.36359656  0.77836361  0.73863732]</span><br><span class="line">min: 0.0592735446598</span><br><span class="line">max: 0.708595838193</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">14</span>,<span class="number">2</span>,<span class="number">-1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(np.argmin(A))<span class="comment">#最小值下标</span></span><br><span class="line">print(np.argmax(A))</span><br><span class="line">print(np.mean(A)) <span class="comment">#平均值</span></span><br><span class="line">print(np.mean(A,axis=<span class="number">0</span>)) <span class="comment">#列的平均值</span></span><br><span class="line">print(np.average(A))</span><br><span class="line">print(np.median(A))<span class="comment">#中位数</span></span><br><span class="line">print(np.cumsum(A))<span class="comment">#累加</span></span><br><span class="line">print(np.diff(A))<span class="comment">#累差</span></span><br><span class="line">print(np.nonzero(A))<span class="comment">#非零数（两个数组，行列坐标）</span></span><br><span class="line">print(np.sort(A))<span class="comment">#逐行排列</span></span><br><span class="line">print(np.transpose(A))<span class="comment">#转置</span></span><br><span class="line">print(A.T)<span class="comment">#转置</span></span><br><span class="line">print((A.T).dot(A))<span class="comment">#矩阵相乘</span></span><br><span class="line">print(np.clip(A,<span class="number">5</span>,<span class="number">9</span>))<span class="comment">#截取</span></span><br><span class="line">print(np.exp(A)) <span class="comment">#指数</span></span><br><span class="line">print(np.log(A))<span class="comment">#对数</span></span><br><span class="line"></span><br><span class="line">B=np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>]]) </span><br><span class="line">print(-B)</span><br><span class="line">C=np.mat(B)<span class="comment">#矩阵化，调用mat()函数可以将数组转化为矩阵</span></span><br><span class="line">print(np.mat(B).I)<span class="comment">#求逆</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[[14 13 12 11]</span><br><span class="line"> [10  9  8  7]</span><br><span class="line"> [ 6  5  4  3]]</span><br><span class="line">11</span><br><span class="line">0</span><br><span class="line">8.5</span><br><span class="line">[ 10.   9.   8.   7.]</span><br><span class="line">8.5</span><br><span class="line">8.5</span><br><span class="line">[ 14  27  39  50  60  69  77  84  90  95  99 102]</span><br><span class="line">[[-1 -1 -1]</span><br><span class="line"> [-1 -1 -1]</span><br><span class="line"> [-1 -1 -1]]</span><br><span class="line">(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2], dtype=int64), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3], dtype=int64))</span><br><span class="line">[[11 12 13 14]</span><br><span class="line"> [ 7  8  9 10]</span><br><span class="line"> [ 3  4  5  6]]</span><br><span class="line">[[14 10  6]</span><br><span class="line"> [13  9  5]</span><br><span class="line"> [12  8  4]</span><br><span class="line"> [11  7  3]]</span><br><span class="line">[[14 10  6]</span><br><span class="line"> [13  9  5]</span><br><span class="line"> [12  8  4]</span><br><span class="line"> [11  7  3]]</span><br><span class="line">[[332 302 272 242]</span><br><span class="line"> [302 275 248 221]</span><br><span class="line"> [272 248 224 200]</span><br><span class="line"> [242 221 200 179]]</span><br><span class="line">[[9 9 9 9]</span><br><span class="line"> [9 9 8 7]</span><br><span class="line"> [6 5 5 5]]</span><br><span class="line">[[  1.20260428e+06   4.42413392e+05   1.62754791e+05   5.98741417e+04]</span><br><span class="line"> [  2.20264658e+04   8.10308393e+03   2.98095799e+03   1.09663316e+03]</span><br><span class="line"> [  4.03428793e+02   1.48413159e+02   5.45981500e+01   2.00855369e+01]]</span><br><span class="line">[[ 2.63905733  2.56494936  2.48490665  2.39789527]</span><br><span class="line"> [ 2.30258509  2.19722458  2.07944154  1.94591015]</span><br><span class="line"> [ 1.79175947  1.60943791  1.38629436  1.09861229]]</span><br><span class="line">[[-2  0]</span><br><span class="line"> [ 0 -3]]</span><br><span class="line">[[ 0.5         0.        ]</span><br><span class="line"> [ 0.          0.33333333]]</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(D)</span><br><span class="line">print(D[<span class="number">2</span>])<span class="comment">#第三行</span></span><br><span class="line">print(D[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">print(D[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">print(D[<span class="number">2</span>,:])<span class="comment">#冒号代表所有数，第3行(下标由0开始)</span></span><br><span class="line">print(D[:,<span class="number">1</span>])<span class="comment">#第2列</span></span><br><span class="line">print(D[<span class="number">1</span>,<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#第二行的小标[1,3)范围的数，不包括3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> D:<span class="comment">#迭代行</span></span><br><span class="line">print(row)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> D.T:<span class="comment">#迭代列</span></span><br><span class="line">print(col)</span><br><span class="line"></span><br><span class="line">print(D.flatten())<span class="comment">#矩阵变成一维（拉直）</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> D.flat:</span><br><span class="line">print(item)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[[ 3  4  5  6]</span><br><span class="line"> [ 7  8  9 10]</span><br><span class="line"> [11 12 13 14]]</span><br><span class="line">[11 12 13 14]</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">[11 12 13 14]</span><br><span class="line">[ 4  8 12]</span><br><span class="line">[8 9]</span><br><span class="line">[3 4 5 6]</span><br><span class="line">[ 7  8  9 10]</span><br><span class="line">[11 12 13 14]</span><br><span class="line">[ 3  7 11]</span><br><span class="line">[ 4  8 12]</span><br><span class="line">[ 5  9 13]</span><br><span class="line">[ 6 10 14]</span><br><span class="line">[ 3  4  5  6  7  8  9 10 11 12 13 14]</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td></tr></table></figure><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并</span></span><br><span class="line">E = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])<span class="comment">#E = np.array([1,1,1])[:,np.newaxis]</span></span><br><span class="line">F = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">print(np.vstack((E,F)))<span class="comment">#上下合并，vertical stack</span></span><br><span class="line">print(np.hstack((E,F)))<span class="comment">#左右合并，horizontal stack</span></span><br><span class="line"></span><br><span class="line">G = np.vstack((E,F))</span><br><span class="line">print(G.shape)</span><br><span class="line">print(G.flatten())</span><br><span class="line"></span><br><span class="line">print(E[np.newaxis,:])<span class="comment">#多加1维度</span></span><br><span class="line">print(E.shape,E[np.newaxis,:].shape)</span><br><span class="line">print(E[:,np.newaxis])</span><br><span class="line">print(E.shape,E[:,np.newaxis].shape)</span><br><span class="line"></span><br><span class="line">E = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">F = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">H = np.concatenate((E,F,F,E),axis=<span class="number">1</span>)<span class="comment">#1是横向合并，0是纵向合并</span></span><br><span class="line">print(E)</span><br><span class="line">print(F)</span><br><span class="line">print(H)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[[1 1 1]</span><br><span class="line"> [2 2 2]]</span><br><span class="line">[1 1 1 2 2 2]</span><br><span class="line">(2, 3)</span><br><span class="line">[1 1 1 2 2 2]</span><br><span class="line">[[1 1 1]]</span><br><span class="line">(3,) (1, 3)</span><br><span class="line">[[1]</span><br><span class="line"> [1]</span><br><span class="line"> [1]]</span><br><span class="line">(3,) (3, 1)</span><br><span class="line">[[1]</span><br><span class="line"> [1]</span><br><span class="line"> [1]]</span><br><span class="line">[[2]</span><br><span class="line"> [2]</span><br><span class="line"> [2]]</span><br><span class="line">[[1 2 2 1]</span><br><span class="line"> [1 2 2 1]</span><br><span class="line"> [1 2 2 1]]</span><br></pre></td></tr></table></figure><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#分割</span></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(np.split(A,<span class="number">3</span>,axis=<span class="number">0</span>))<span class="comment">#横向分割成3份</span></span><br><span class="line">print(np.split(A,<span class="number">2</span>,axis=<span class="number">1</span>))<span class="comment">#纵向分割成2份</span></span><br><span class="line"><span class="comment">#不等量分割</span></span><br><span class="line">print(np.array_split(A,<span class="number">3</span>,axis=<span class="number">1</span>))<span class="comment">#纵向分割成3份</span></span><br><span class="line"></span><br><span class="line">print(np.vsplit(A,<span class="number">3</span>))<span class="comment">#横向分割成3份</span></span><br><span class="line">print(np.hsplit(A,<span class="number">2</span>))<span class="comment">#纵向分割成2份</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line">[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span><br><span class="line">[array([[0, 1],</span><br><span class="line">       [4, 5],</span><br><span class="line">       [8, 9]]), array([[ 2,  3],</span><br><span class="line">       [ 6,  7],</span><br><span class="line">       [10, 11]])]</span><br><span class="line">[array([[0, 1],</span><br><span class="line">       [4, 5],</span><br><span class="line">       [8, 9]]), array([[ 2],</span><br><span class="line">       [ 6],</span><br><span class="line">       [10]]), array([[ 3],</span><br><span class="line">       [ 7],</span><br><span class="line">       [11]])]</span><br><span class="line">[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span><br><span class="line">[array([[0, 1],</span><br><span class="line">       [4, 5],</span><br><span class="line">       [8, 9]]), array([[ 2,  3],</span><br><span class="line">       [ 6,  7],</span><br><span class="line">       [10, 11]])]</span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#赋值</span></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">b=a</span><br><span class="line">c=a</span><br><span class="line">d=b</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">11</span><span class="comment">#只要a变，其他关联变量也变</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(b <span class="keyword">is</span> a)</span><br><span class="line">print(c)</span><br><span class="line">print(c <span class="keyword">is</span> a)</span><br><span class="line">print(d)</span><br><span class="line">print(d <span class="keyword">is</span> a)</span><br><span class="line"></span><br><span class="line">b = a.copy()<span class="comment">#a和b不关联了</span></span><br><span class="line">print(b <span class="keyword">is</span> a)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3]</span><br><span class="line">[11  1  2  3]</span><br><span class="line">[11  1  2  3]</span><br><span class="line">True</span><br><span class="line">[11  1  2  3]</span><br><span class="line">True</span><br><span class="line">[11  1  2  3]</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;numpy-属性&quot;&gt;&lt;a href=&quot;#numpy-属性&quot; class=&quot;headerlink&quot; title=&quot;numpy 属性&quot;&gt;&lt;/a&gt;numpy 属性&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct-list</title>
    <link href="http://yoursite.com/2018/12/27/struct-list/"/>
    <id>http://yoursite.com/2018/12/27/struct-list/</id>
    <published>2018-12-27T03:09:17.000Z</published>
    <updated>2019-03-18T01:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-顺序表"><a href="#数据结构-顺序表" class="headerlink" title="数据结构 顺序表"></a>数据结构 顺序表</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表的顺序表的动态分配类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="keyword">int</span> MaxSize,length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> position, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> position, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListSearch</span><span class="params">(SqList &amp;L, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListUpdate</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> position, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListShow</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReverse</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Serch_Min</span><span class="params">(SqList &amp;L,ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Min</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Same</span><span class="params">(SqList &amp;L, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Range_order</span><span class="params">(SqList &amp;L, ElemType start, ElemType end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Range_disorder</span><span class="params">(SqList &amp;L, ElemType start, ElemType end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList &amp;L)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化List</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span></span><br><span class="line">L.data = <span class="keyword">new</span> ElemType[InitSize];</span><br><span class="line"><span class="keyword">if</span>(!L.data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作(列表，插入位置，插入元素) 平均 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> position, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (position&lt;<span class="number">1</span> || position&gt;L.length+<span class="number">1</span>)<span class="comment">//可插位置有n+1个</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length == L.MaxSize)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L.length; i &gt;= position; i--)<span class="comment">//往后移位</span></span><br><span class="line">L.data[i] = L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">L.data[position<span class="number">-1</span>] = e;<span class="comment">//找到合适位置插入元素</span></span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作(列表，删除位置，返回被删元素) 平均 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> position, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (position&lt;<span class="number">1</span> || position&gt;L.length) <span class="comment">//可删位置有n个</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[position<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = position; i &lt; L.length; i++)<span class="comment">//往前移位</span></span><br><span class="line">L.data[i<span class="number">-1</span>] = L.data[i]; </span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作(列表，待查找元素) 平均 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListSearch</span><span class="params">(SqList &amp;L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> position;</span><br><span class="line"><span class="keyword">for</span> (position = <span class="number">0</span>; position &lt; L.length; ++position)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.data[position] == e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> position+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新操作(列表，位置，待更新元素) 平均 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListUpdate</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> position, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (position&lt;<span class="number">1</span> || position&gt;L.length) <span class="comment">//可更新位置有n个</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">L.data[position<span class="number">-1</span>] = e; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示操作(列表) 平均 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListShow</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no List\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)<span class="comment">//往前移位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, L.data[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回List长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素顺序逆置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReverse</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType tmp;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ListReverse no List\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length/<span class="number">2</span>; i++)  <span class="comment">//往前移位</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp  = L.data[i];  <span class="comment">//第一与最后的交换，第二与倒数第二交换，以此类推</span></span><br><span class="line">            L.data[i] = L.data[L.length<span class="number">-1</span>-i];</span><br><span class="line">            L.data[L.length<span class="number">-1</span>-i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最小值(list,返回最小值) 函数返回位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Serch_Min</span><span class="params">(SqList &amp;L,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">-1</span>;</span><br><span class="line">    e = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] &lt; e)</span><br><span class="line">        &#123;</span><br><span class="line">            e = L.data[i];</span><br><span class="line">            position = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最小值，并且用最后元素替补(list,返回最小值)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Min</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> position = Serch_Min(L,e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        L.data[position<span class="number">-1</span>] = L.data[L.length<span class="number">-1</span>];</span><br><span class="line">        L.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除与e相同的值 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Same</span><span class="params">(SqList &amp;L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//不等于e的值个数</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.data[i] != e)</span><br><span class="line">            &#123;</span><br><span class="line">                L.data[k] = L.data[i];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is not in List\n"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L.length = k;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一定范围的值 [start,end](闭区间)(前提L是个有序表)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Range_order</span><span class="params">(SqList &amp;L, ElemType start, ElemType end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s_pos,e_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// int s_pos = ListSearch(L,start);    //获得start的位置 //不可以这样 start未必在list中</span></span><br><span class="line">    <span class="keyword">for</span> (s_pos = <span class="number">0</span>; s_pos &lt; L.length &amp;&amp; L.data[s_pos] &lt; start ; ++s_pos);    <span class="comment">//找到 &gt;=start 第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("%d\n",s_pos);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_pos &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//所有值均小于s  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (e_pos = s_pos ; e_pos &lt; L.length &amp;&amp; L.data[e_pos] &lt;= end ; ++e_pos);    <span class="comment">//找到 &gt;t 第一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf("%d\n",);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; e_pos &lt; L.length; s_pos++,e_pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[s_pos] = L.data[e_pos];</span><br><span class="line">        <span class="comment">//printf("%d\n",L.data[s_pos]);</span></span><br><span class="line">        <span class="comment">//printf("%d\n",s_pos);</span></span><br><span class="line">        <span class="comment">//printf("%d\n",e_pos);</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    L.length = s_pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一定范围的值 [start,end](闭区间)(L是个无序表)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Range_disorder</span><span class="params">(SqList &amp;L, ElemType start, ElemType end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//处于范围内的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]&gt;=start &amp;&amp; L.data[i]&lt;=end)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L.data[i-k] = L.data[i];    <span class="comment">//当前元素前移k个位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并A B两个有序表，成新的C有序表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListMergebyorder</span><span class="params">(SqList A,SqList B,SqList &amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.length+B.length &gt; C.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length &amp;&amp; j&lt;B.length) <span class="comment">//两两比较，小的存入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.data[i] &lt;= B.data[j])</span><br><span class="line">            C.data[k++] = A.data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C.data[k++] = B.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length)               <span class="comment">//还剩一个没有比较完成的顺序</span></span><br><span class="line">        C.data[k++] = A.data[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B.length)</span><br><span class="line">        C.data[k++] = B.data[j++];</span><br><span class="line">    </span><br><span class="line">    C.length = k+l;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-顺序表&quot;&gt;&lt;a href=&quot;#数据结构-顺序表&quot; class=&quot;headerlink&quot; title=&quot;数据结构 顺序表&quot;&gt;&lt;/a&gt;数据结构 顺序表&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct-sort</title>
    <link href="http://yoursite.com/2018/12/27/struct-sort/"/>
    <id>http://yoursite.com/2018/12/27/struct-sort/</id>
    <published>2018-12-27T03:04:58.000Z</published>
    <updated>2019-03-18T01:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-排序"><a href="#数据结构-排序" class="headerlink" title="数据结构 排序"></a>数据结构 排序</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORT_FUNCTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORT_FUNCTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 11111</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>;<span class="comment">//快速</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//简单插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//折半</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//希尔</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//选择</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;<span class="comment">//堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType data[],<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElemType &amp;bottom,ElemType &amp;top)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType datas[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>;<span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sort_function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i]==MAX || data[i]==<span class="number">0</span>)<span class="comment">//跳过输出哨兵</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序(稳定)(可用于顺序结构和链式结构)</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">最好情况：原序是顺序 O(N)</span></span><br><span class="line"><span class="comment">最坏情况：原序是逆序 O(N^2)----平均</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个tmp中间量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElemType tmp;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="comment">//i指向最后一个元素，第一趟比较num-1次（确定最大值）</span></span><br><span class="line"><span class="comment">//第二趟比较num-2次(确定第二最大值)，以此类推，需要i--</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &gt; data[j+<span class="number">1</span>])<span class="comment">//较大者往后交换</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = data[j];</span><br><span class="line">data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">data[j+<span class="number">1</span>] = tmp;</span><br><span class="line">flag  = <span class="literal">true</span>;<span class="comment">//交换标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)<span class="comment">//若没有交换，则证明有序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序(不稳定)（平均情况往最好情况靠，一般序列无序，或人为打乱）</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">最好情况:无序O(Nlog2N)-----平均</span></span><br><span class="line"><span class="comment">最坏情况:有序或者逆序O(N^2)</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">最好情况：O(log2(N+1))容量与递归最大深度一致----平均</span></span><br><span class="line"><span class="comment">最坏情况：O(N)进行N-1次递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pivotpos = Partition(data,low,high);<span class="comment">//找到基准位置</span></span><br><span class="line">QuickSort(data,low,pivotpos<span class="number">-1</span>);<span class="comment">//小于基准的子表，继续执行快速排序</span></span><br><span class="line">QuickSort(data,pivotpos+<span class="number">1</span>,high);<span class="comment">//大于基准的子表，继续执行快速排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快速排序有分治思想（这是一个划分方法）</span></span><br><span class="line"><span class="comment">每次总是对当前表中第一个元素作为基准，对表进行划分</span></span><br><span class="line"><span class="comment">将表中大于基准的元素往右移，小于基准的值往左移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElemType pivot = data[low];<span class="comment">//基准，并且暂存基准的值</span></span><br><span class="line"><span class="keyword">while</span>(low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=pivot)</span><br><span class="line">--high;<span class="comment">//循环比较，遇到小于基准的数，跳出循环</span></span><br><span class="line">data[low] = data[high];<span class="comment">//小于基准的值往放入低位（往左移）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; data[low]&lt;=pivot)</span><br><span class="line">++low;<span class="comment">//循环比较，遇到大于基准的数，跳出循环</span></span><br><span class="line">data[high] = data[low];<span class="comment">//大于基准的值往放入高位（往右移）</span></span><br><span class="line">&#125;</span><br><span class="line">data[low] = pivot;<span class="comment">//最后low=high，则放入基准，左边的值&lt;基准&lt;右边的值</span></span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入排序(稳定)(可用于顺序结构和链式结构)</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">最好情况：原序是顺序 O(N)</span></span><br><span class="line"><span class="comment">最坏情况：原序是逆序 O(N^2)----平均</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个data[0]哨兵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="comment">//1-&gt;n 是元素 ，0是哨兵 ，由2开始，插入到前面有序序列</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[i] &lt; data[i<span class="number">-1</span>])<span class="comment">//当前元素小于前驱元素</span></span><br><span class="line">&#123;</span><br><span class="line">data[<span class="number">0</span>] = data[i];  <span class="comment">//将当前元素放入哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在有序序列中找到合适位置，将大于哨兵的往后移动</span></span><br><span class="line"><span class="keyword">for</span> (j = i<span class="number">-1</span>; data[<span class="number">0</span>] &lt; data[j]; j--)</span><br><span class="line">data[j+<span class="number">1</span>] = data[j];</span><br><span class="line">data[j+<span class="number">1</span>] = data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>] = MAX;<span class="comment">//设定哨兵为定值，过滤输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*希尔排序(不稳定)(可用于顺序结构，不可用于链式结构)</span></span><br><span class="line"><span class="comment">插入排序和冒泡排序都是一次只交换相邻数据，为了优化插入排序速度，</span></span><br><span class="line"><span class="comment">可以一次性能多次交换相邻较远数据，就是希尔排序</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">1、按照增量分组</span></span><br><span class="line"><span class="comment">2、在分组中进行插入排序</span></span><br><span class="line"><span class="comment">3、将增量减小在进行分组和拆入排序</span></span><br><span class="line"><span class="comment">4、用于大量数据中，速度效果比较明显</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">时间复杂度</span></span><br><span class="line"><span class="comment">因为增量设置不同，所以情况不同，数学上为找出最好情况，处于O(Nlog2N)~Θ(N^2)之间</span></span><br><span class="line"><span class="comment">最坏情况就是：增量不为1时没有排序，直到增量为1的时候才进行排序 Θ(N^2)</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个data[0]暂存单元，不是哨兵</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">更多增量序列(优化增量序列则可以优化希尔序列)</span></span><br><span class="line"><span class="comment">1、传统希尔增量序列</span></span><br><span class="line"><span class="comment">D = length/2, 然后一直减半减半直至D=1 </span></span><br><span class="line"><span class="comment">2、Hibbard增量序列</span></span><br><span class="line"><span class="comment">D = 2^k - 1,----相邻元素互质</span></span><br><span class="line"><span class="comment">最坏情况：Θ(N^3/2)</span></span><br><span class="line"><span class="comment">猜想时间：O(N^5/4)&gt;O(N)</span></span><br><span class="line"><span class="comment">3、Sedgewick增量排序</span></span><br><span class="line"><span class="comment">&#123;1,5,19,41,109....&#125;</span></span><br><span class="line"><span class="comment">D = 9*4^i - 9*2^i +1 OR 4^i - 3*2^i +1</span></span><br><span class="line"><span class="comment">猜想时间：最好情况O(N^7/6)最坏情况O(N^4/3)</span></span><br><span class="line"><span class="comment">在数据量上万时用此增量比较好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2  3 4 5  6 7  8  9  10</span></span><br><span class="line"><span class="comment">3 55 6 7 34 5 36 20 10 32</span></span><br><span class="line"><span class="comment">dk = 10/2=5||</span></span><br><span class="line"><span class="comment">第一趟3-----------5</span></span><br><span class="line"><span class="comment">  |  |</span></span><br><span class="line"><span class="comment">  36----------55</span></span><br><span class="line"><span class="comment">   | |</span></span><br><span class="line"><span class="comment">   6-----------20</span></span><br><span class="line"><span class="comment">     ||</span></span><br><span class="line"><span class="comment">     7------------10</span></span><br><span class="line"><span class="comment">      |   |</span></span><br><span class="line"><span class="comment">      32   34</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 36 6 7 32 5 55 20 10 34</span></span><br><span class="line"><span class="comment">dk = 5/2=2|   |  |   |</span></span><br><span class="line"><span class="comment">第二趟 3------7------34-------55</span></span><br><span class="line"><span class="comment">  | | |</span></span><br><span class="line"><span class="comment">  20-----32------36</span></span><br><span class="line"><span class="comment">   |||</span></span><br><span class="line"><span class="comment"> 5------6-------10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3 20 5 7 32 6 34 36 10 55</span></span><br><span class="line"><span class="comment">dk = 2/2=1</span></span><br><span class="line"><span class="comment">第三趟3 5 6 7 10 20 32 34 36 55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dk,i,j;</span><br><span class="line"><span class="keyword">for</span> (dk = num/<span class="number">2</span>; dk &gt;=<span class="number">1</span>; dk=dk/<span class="number">2</span>)<span class="comment">//dk 是增量序列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = dk+<span class="number">1</span>; i &lt;= num; ++i)<span class="comment">//上例子得，列表由1开始，则比较从i=6开始（由1开始也可以，跳出循环比较i&lt;=num-dk）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[i]&lt;data[i-dk])</span><br><span class="line">&#123;</span><br><span class="line">data[<span class="number">0</span>] = data[i];<span class="comment">//需将data[i]插入有序增量子表</span></span><br><span class="line"><span class="keyword">for</span> (j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; data[<span class="number">0</span>]&lt;data[j]; j-=dk)</span><br><span class="line">&#123;</span><br><span class="line">data[j+dk] = data[j];</span><br><span class="line">&#125;</span><br><span class="line">data[j+dk] = data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>] = MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*折半排序(稳定)(只能用于顺序结构)(与初始顺序无关)</span></span><br><span class="line"><span class="comment">（相对简单插入减少了元素比较次数）</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">平均情况：O(n^2)</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个data[0]哨兵</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   lowmid   high </span></span><br><span class="line"><span class="comment">| |   |</span></span><br><span class="line"><span class="comment">1 2  3 4 5  6 7  8  9  10</span></span><br><span class="line"><span class="comment">3 55 6 7 34 5 36 20 10 32 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= num; ++i)<span class="comment">//依次将data[2]~data[n]插入到前面已排序序列</span></span><br><span class="line">&#123;</span><br><span class="line">data[<span class="number">0</span>] = data[i];<span class="comment">//暂存</span></span><br><span class="line">low = <span class="number">1</span>;</span><br><span class="line">high = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high)/<span class="number">2</span>;<span class="comment">//取中间结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>]&lt;data[mid])<span class="comment">//查左半子表</span></span><br><span class="line">high = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid+<span class="number">1</span>;    <span class="comment">//查右半子表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = i<span class="number">-1</span>; j&gt;= high+<span class="number">1</span>; --j)<span class="comment">//统一往后移，空出插入位置</span></span><br><span class="line">data[j+<span class="number">1</span>] = data[j];</span><br><span class="line">data[high+<span class="number">1</span>] = data[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>] = MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择排序(不稳定)（与初始顺序无关）</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">最好情况：O(n^2)</span></span><br><span class="line"><span class="comment">最坏情况：O(n^2)----平均</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个tmp中间量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line">ElemType tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(data[j] &lt; data[min])<span class="comment">//找到最小元素下标</span></span><br><span class="line">min = j;</span><br><span class="line"><span class="keyword">if</span> (min != i)<span class="comment">//不是当前元素,则交换</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = data[i];</span><br><span class="line">data[i] = data[min];</span><br><span class="line">data[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（大根堆）堆排序（不稳定）(选择排序)（常用于优先级队列，在操作系统作业调度使用）</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">建堆时间O(n)，调整时间O(h)</span></span><br><span class="line"><span class="comment">平均时间长度：O(nlog2n)</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(1)//一个辅助单元</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2  3 4 5  6 7  8  9  10</span></span><br><span class="line"><span class="comment">3 55 6 7 34 5 36 20 10 32</span></span><br><span class="line"><span class="comment">[3]    [k]</span></span><br><span class="line"><span class="comment">  [55]   [6] [2k]  [2k+1]</span></span><br><span class="line"><span class="comment">  [7]  [34] [5]   [36]  堆左右结点对应list下标</span></span><br><span class="line"><span class="comment">    [20] [10] [32]</span></span><br><span class="line"><span class="comment">由[n/2]=(1+10)/2=&gt;5开始</span></span><br><span class="line"><span class="comment">然后 4,3,2,1到根结束，选出最大者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BuildMaxHeap(data,num);<span class="comment">//初始建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i&gt;=<span class="number">1</span>; i--)<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">&#123;</span><br><span class="line">Swap(data[i],data[<span class="number">1</span>]);<span class="comment">//输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">AdjustDown(data,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//整理，把剩余的i-1个元素整理成堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//最后一个结点，直接输出（没有比较）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType data[],<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">//从i=[n/2]~1反复调整堆</span></span><br><span class="line">&#123;</span><br><span class="line">AdjustDown(data,i,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*函数将元素向下调整</span></span><br><span class="line"><span class="comment">[23]         data[0]=23     [49]</span></span><br><span class="line"><span class="comment">/\     -----------------&gt; /\       然后再从[10]开始继续重复操作</span></span><br><span class="line"><span class="comment">  [10][49] [23]&lt;-&gt;[49]  [10][23]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType data[],<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">data[<span class="number">0</span>] = data[k];<span class="comment">//data[0]暂存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k; i &lt;= num; i *= <span class="number">2</span>)<span class="comment">//沿key较大的子节点向下筛选（2k是左结点）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;num &amp;&amp; data[i]&lt;data[i+<span class="number">1</span>])</span><br><span class="line">i++;<span class="comment">//取key较大的子节点下标</span></span><br><span class="line"><span class="keyword">if</span> (data[<span class="number">0</span>] &gt;= data[i])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//筛选结束</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">data[k] = data[i];<span class="comment">//将data[i]调整到双亲结点上，</span></span><br><span class="line">k = i;<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[k] = data[<span class="number">0</span>];<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将data[1]输出，在data[0]=data[n],堆底元素赋给堆顶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElemType &amp;bottom,ElemType &amp;top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, top);</span><br><span class="line">top = bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*归并排序</span></span><br><span class="line"><span class="comment">将两个或两个以上的有序表合并成表的过程。</span></span><br><span class="line"><span class="comment">（由原始表整体划分到个体，再递归，将两两归并）</span></span><br><span class="line"><span class="comment">O(NlogN)没有最好最坏情况</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">O(nlog2n)没有最好最坏情况</span></span><br><span class="line"><span class="comment">空间复杂度：</span></span><br><span class="line"><span class="comment">O(n)//常用外不排序，因为需要辅助空间与原来表长等大小</span></span><br><span class="line"><span class="comment">   1 2  3 4 5  6 7  8  9  10</span></span><br><span class="line"><span class="comment">   3 55 6 7 34 5 36 20 10 32初始状态</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  [3 55 6 7 34]     [5 36 20 10 32]</span></span><br><span class="line"><span class="comment">         |   |</span></span><br><span class="line"><span class="comment">   [3 55 6]   [7 34]      [5 36 20]  [10 32]</span></span><br><span class="line"><span class="comment">   |        |            |          |</span></span><br><span class="line"><span class="comment"> [3 55]  [6] [7] [34]  [5 36]  [20] [10] [32]</span></span><br><span class="line"><span class="comment">   |         |     </span></span><br><span class="line"><span class="comment">[3] [55] [6] [7] [34] [5] [36] [20] [10] [32]划分完成(开始归并)</span></span><br><span class="line"><span class="comment">   |      |    |    |  |    |</span></span><br><span class="line"><span class="comment">     [3 55]  [6]  [7 34]  [5 36]   [20]  [10 32]</span></span><br><span class="line"><span class="comment">        ||         ||</span></span><br><span class="line"><span class="comment">      [3 6 55]   [7 34] [5 20 36] [10 32]</span></span><br><span class="line"><span class="comment">|   |</span></span><br><span class="line"><span class="comment">          [3 6 7 34 55]      [5 10 20 32 36]copydata(最后一趟)</span></span><br><span class="line"><span class="comment">                          |</span></span><br><span class="line"><span class="comment">              [3 5 6 7 10 20 32 34 36 55]data（两个子表，逐个比较，小的放进data）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low&lt;high)<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;<span class="comment">//从中间划分两个子序列</span></span><br><span class="line">MergeSort(data,low,mid);<span class="comment">//对左侧子序列划分进行归并排序</span></span><br><span class="line">MergeSort(data,mid+<span class="number">1</span>,high);<span class="comment">//对右侧子序列划分进行归并排序</span></span><br><span class="line">Merge(data,low,mid,high);<span class="comment">//归并（进行子表中的排序）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="comment">//data[low.....mid],data[mid+1......high],各自有序，将他们合并成一个有序表</span></span><br><span class="line">ElemType copydata[<span class="number">11</span>];<span class="comment">//辅助变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType data[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span> (k = low; k &lt;= high; ++k)<span class="comment">//复制原表到辅助表</span></span><br><span class="line">copydata[k] = data[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=low,j=mid+<span class="number">1</span>,k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (copydata[i]&lt;copydata[j])<span class="comment">//比较copydata的左右表元素</span></span><br><span class="line">data[k] = copydata[i++];<span class="comment">//较小值复制到data中</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">data[k] = copydata[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为合并的两个部分长度不一定相等，总有多余出来的元素，在下面两个循环只会执行其中一个</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">data[k++] = copydata[i++];<span class="comment">//若第一表未检测完，复制</span></span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">data[k++] = copydata[j++];<span class="comment">//若第二表未检测完，复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-排序&quot;&gt;&lt;a href=&quot;#数据结构-排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构 排序&quot;&gt;&lt;/a&gt;数据结构 排序&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct-threadtree</title>
    <link href="http://yoursite.com/2018/12/27/struct-threadtree/"/>
    <id>http://yoursite.com/2018/12/27/struct-threadtree/</id>
    <published>2018-12-27T03:01:45.000Z</published>
    <updated>2019-03-18T01:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-线索二叉树"><a href="#数据结构-线索二叉树" class="headerlink" title="数据结构 线索二叉树"></a>数据结构 线索二叉树</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉链表，利用空余连接指向直连前驱或者后继</span></span><br><span class="line"><span class="comment"> * tag = 1时，lchild指向前驱，rchild指向后继，tag = 0时，lchild、rchild指向子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">(ThreadTree &amp;T, ElemType Data, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(ThreadTree &amp;T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"threadtree.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一棵普通二叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">(ThreadTree &amp;T, ElemType Data, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//index=0代表根节点，1表示左子树结点，2表示右子树结点</span></span><br><span class="line"><span class="keyword">char</span> data = Data;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="string">'#'</span>)<span class="comment">//在循环中，输错重新输入</span></span><br><span class="line">&#123;</span><br><span class="line">data = Data;<span class="comment">//输入错误时，修正data值</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input root :"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %c to left child :"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %c to right child :"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;data);</span><br><span class="line"><span class="keyword">if</span> (data != <span class="string">'#'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data &gt;= <span class="string">'a'</span> &amp;&amp; data &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">T = <span class="keyword">new</span> ThreadNode();</span><br><span class="line">T-&gt;data = data;</span><br><span class="line">T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">InitTree(T-&gt;lchild, T-&gt;data, <span class="number">1</span>);    <span class="comment">//子树，父亲节点的值，标识</span></span><br><span class="line">InitTree(T-&gt;rchild, T-&gt;data, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Not in range 'a-z'\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(ThreadTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c    %d    %c    %d    %c\n"</span>,T-&gt;lchild-&gt;data,T-&gt;ltag,T-&gt;data,T-&gt;rtag,T-&gt;rchild-&gt;data);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c    %d    %c    %d    %c\n"</span>,<span class="string">'#'</span>,T-&gt;ltag,T-&gt;data,T-&gt;rtag,T-&gt;rchild-&gt;data);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c    %d    %c    %d    %c\n"</span>,T-&gt;lchild-&gt;data,T-&gt;ltag,T-&gt;data,T-&gt;rtag,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c    %d    %c    %d    %c\n"</span>,<span class="string">'#'</span>,T-&gt;ltag,T-&gt;data,T-&gt;rtag,<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;ltag != <span class="number">1</span>)</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span>(T-&gt;rtag != <span class="number">1</span>)</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历对二叉树线索化的递归算法 (pre是前驱，p是后继)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InThread(p-&gt;lchild,pre);<span class="comment">//递归，线索化左子树</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;lchild = pre;</span><br><span class="line">p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rchild = p;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = p;<span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">InThread(p-&gt;rchild,pre);<span class="comment">//线索化右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T!=<span class="literal">NULL</span>)<span class="comment">//前提传入 一颗二叉树，将其线索化</span></span><br><span class="line">&#123;</span><br><span class="line">InThread(T,pre);</span><br><span class="line">pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//处理遍历的最好一个结点</span></span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树中序序列下第一个节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)<span class="comment">//最左下结点，不一定是叶子结点</span></span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树中序序列下后继节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;rchild;<span class="comment">//rtag == 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p != <span class="literal">NULL</span>; p=Nextnode(p))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-线索二叉树&quot;&gt;&lt;a href=&quot;#数据结构-线索二叉树&quot; class=&quot;headerlink&quot; title=&quot;数据结构 线索二叉树&quot;&gt;&lt;/a&gt;数据结构 线索二叉树&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_bstree</title>
    <link href="http://yoursite.com/2018/12/26/struct-bstree/"/>
    <id>http://yoursite.com/2018/12/26/struct-bstree/</id>
    <published>2018-12-26T06:31:44.000Z</published>
    <updated>2019-03-18T01:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-排序树"><a href="#数据结构-排序树" class="headerlink" title="数据结构 排序树"></a>数据结构 排序树</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BSTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; </span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTNode BSTNode;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key, BSTNode *&amp;p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, ElemType k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BiTree &amp;T, ElemType str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JudgeBST</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BiTree T,BSTNode *x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JudgeAVL</span><span class="params">(BiTree T,<span class="keyword">int</span>  &amp;balance,<span class="keyword">int</span> &amp;h)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bstree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树 查找函数 返回指向关键字值为key的结点指针，</span></span><br><span class="line"><span class="comment">//若不存在，返回NULL</span></span><br><span class="line"><span class="comment">//非递归方法</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key, BSTNode *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//指向被查找结点的双亲，用于插入和删除操作</span></span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">T = T-&gt;lchild;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T = T-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树 插入一个关键字为k的结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, ElemType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> BSTNode();</span><br><span class="line">T-&gt;data = k;</span><br><span class="line">T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1 表示成功</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;data)&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//存在相同关键字</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;data)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BiTree &amp;T, ElemType str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//用关键字数组str[]建立一个二叉排序树</span></span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">BST_Insert(T,str[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) </span><br><span class="line">&#123;</span><br><span class="line">InOrderTraverse(T-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;data);</span><br><span class="line">InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType predt = <span class="number">-3276</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是二叉排序树（中序遍历保持曾序则为排序树）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JudgeBST</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line"><span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//空树</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t1 = JudgeBST(T-&gt;lchild);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t1==<span class="number">0</span> || predt&gt;=T-&gt;data)<span class="comment">//左子树返回 或者 前驱大于当前节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">predt = T-&gt;data;<span class="comment">//保存当前节点的关键字</span></span><br><span class="line"></span><br><span class="line">t2 = JudgeBST(T-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> t2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结点在二叉排序树的层数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BiTree T,BSTNode *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">BiTree t = T;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">while</span>(t-&gt;data != x-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data &lt; x-&gt;data)</span><br><span class="line">t = t-&gt;rchild;<span class="comment">//去右子树查找</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t = t-&gt;lchild;<span class="comment">//去左子树查找</span></span><br><span class="line">n++;<span class="comment">//层次+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">i = -i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JudgeAVL</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tl=<span class="number">0</span>,tr=<span class="number">0</span>,hl=<span class="number">0</span>,hr=<span class="number">0</span>;<span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line"><span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">h = <span class="number">0</span>;<span class="comment">//空树，高度为0</span></span><br><span class="line">balance = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">h = <span class="number">1</span>;<span class="comment">//仅有根节点，高度为1</span></span><br><span class="line">balance = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">JudgeAVL(T-&gt;lchild,tl,hl);<span class="comment">//判断左右子树的高度和平衡度</span></span><br><span class="line">JudgeAVL(T-&gt;rchild,tr,hr);</span><br><span class="line">h = (hl&gt;hr ? hl:hr) + <span class="number">1</span>;<span class="comment">//取深度大的一边</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(hl-hr) &lt; <span class="number">2</span>)</span><br><span class="line">balance = tl &amp;&amp; tr;<span class="comment">//逻辑与，左右子树均平衡（1）二叉树才平衡</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">balance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-排序树&quot;&gt;&lt;a href=&quot;#数据结构-排序树&quot; class=&quot;headerlink&quot; title=&quot;数据结构 排序树&quot;&gt;&lt;/a&gt;数据结构 排序树&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_graph</title>
    <link href="http://yoursite.com/2018/12/26/struct-graph/"/>
    <id>http://yoursite.com/2018/12/26/struct-graph/</id>
    <published>2018-12-26T06:22:27.000Z</published>
    <updated>2019-03-18T01:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-图"><a href="#数据结构-图" class="headerlink" title="数据结构 图"></a>数据结构 图</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><h5 id="algraph-h-邻接表"><a href="#algraph-h-邻接表" class="headerlink" title="algraph.h (邻接表)"></a>algraph.h (邻接表)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGRAPH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGRAPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100<span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//带权图中边上权的数据类型</span></span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArchNode</span>//边表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//边结点在顶点表中的下标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArchNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个边结点</span></span><br><span class="line">EdgeType weight;<span class="comment">//权重</span></span><br><span class="line"><span class="comment">//还可以添加更多属性</span></span><br><span class="line">&#125;ArchNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>//顶点表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType data;<span class="comment">//顶点的标识（不是权值）</span></span><br><span class="line">ArchNode *first;<span class="comment">//第一个邻接点</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AdjList vertices;<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum;<span class="comment">//顶点数，弧数</span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 邻接表：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    顶点表      边结点</span></span><br><span class="line"><span class="comment"> *   AdjList    ArchNode</span></span><br><span class="line"><span class="comment"> *0 [v1,]----&gt;[3,]-&gt;[2,]-&gt;[1,^]</span></span><br><span class="line"><span class="comment"> *1 [v2,]----&gt;[0,^]</span></span><br><span class="line"><span class="comment"> *2 [v3,]----&gt;[3,]-&gt;[0,^]</span></span><br><span class="line"><span class="comment"> *3 [v4,]----&gt;[2,]-&gt;[0,^]</span></span><br><span class="line"><span class="comment"> *（该表表示的是无向图的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateALVex</span><span class="params">(ALGraph &amp;G,VertexType v)</span></span>;</span><br><span class="line"><span class="function">VertexType <span class="title">FindALVex</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowALGraph</span><span class="params">(ALGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function">EdgeType <span class="title">GetWeight</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FistNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//求G图中顶点x的第一个邻接点，返回订点号，若没有或不存在x，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是最后一个，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> arcs[MaxVertexNum][MaxVertexNum])</span></span>;<span class="comment">//邻接表转换邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph &amp;G)</span></span>;<span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Non_RC</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph &amp;G)</span></span>;<span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Adjacent</span><span class="params">(ALGraph G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//判断是否存在边 &lt;x,y&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Neighbors</span><span class="params">(ALGraph G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//列出G图与顶点x相邻的边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertVertex</span><span class="params">(ALGraph G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//插入一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteVertex</span><span class="params">(ALGraph G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//删除一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddEdge</span><span class="params">(ALGraph G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//若&lt;x,y&gt;不存在边，则在两个顶点之间插入边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveEdge</span><span class="params">(ALGraph G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//若&lt;x,y&gt;存在边，则删除边</span></span><br><span class="line"><span class="comment">// EdgeType GetEdgeValue(ALGraph G,int x,int y);//获取&lt;x,y&gt;权值</span></span><br><span class="line"><span class="comment">// void SetEdgeValue(ALGraph G,int x,int y,EdgeType v);//设置&lt;x,y&gt;权值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="mgraph-h-矩阵"><a href="#mgraph-h-矩阵" class="headerlink" title="mgraph.h (矩阵)"></a>mgraph.h (矩阵)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MGRAPH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MGRAPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 500<span class="comment">//定义无穷值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100<span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//带权图中边上权的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType Vex[MaxVertexNum];<span class="comment">//顶点表</span></span><br><span class="line">EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前结点、弧数</span></span><br><span class="line">&#125;MatrixGraph;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vex[] = 0 1 2 3 </span></span><br><span class="line"><span class="comment"> *         a b c d</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> *            0 1 2 3 </span></span><br><span class="line"><span class="comment"> * Edge[][] =  a b c d </span></span><br><span class="line"><span class="comment"> *   a</span></span><br><span class="line"><span class="comment"> *   b</span></span><br><span class="line"><span class="comment"> *   c</span></span><br><span class="line"><span class="comment"> *   d</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span>;<span class="comment">//找到顶点标识在顶点表的位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateUDG</span><span class="params">(MatrixGraph &amp;G)</span></span>;<span class="comment">//创建无向图 以邻接矩阵存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMGraph</span><span class="params">(MatrixGraph &amp;G)</span></span>;<span class="comment">//显示邻接矩阵</span></span><br><span class="line"><span class="function">VertexType <span class="title">FindVex</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Adjacent</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//判断是否存在边 &lt;x,y&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Neighbors</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//列出G图与顶点x相邻的边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertVertex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span>;<span class="comment">//插入一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteVertex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span>;<span class="comment">//删除一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddEdge</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType v)</span></span>;<span class="comment">//若&lt;x,y&gt;不存在边，则在两个顶点之间插入边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveEdge</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//若&lt;x,y&gt;存在边，则删除边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FistNeighbor</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x)</span></span>;<span class="comment">//求G图中顶点x的第一个邻接点，返回订点号，若没有或不存在x，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextNeighbor</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是最后一个，则返回-1</span></span><br><span class="line"><span class="function">EdgeType <span class="title">GetEdgeValue</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//获取&lt;x,y&gt;权值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetEdgeValue</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType v)</span></span>;<span class="comment">//设置&lt;x,y&gt;权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MatrixGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Non_RC</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MatrixGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowDistance</span><span class="params">(MatrixGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTree</span><span class="params">(MatrixGraph &amp;G)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Is_Tree</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> &amp;Vnum,<span class="keyword">int</span> &amp;Enum)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="algraph-c"><a href="#algraph-c" class="headerlink" title="algraph.c"></a>algraph.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algraph.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到顶点标识在顶点表的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateALVex</span><span class="params">(ALGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == G.vertices[i].data)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过下标找到顶点标识</span></span><br><span class="line"><span class="function">VertexType <span class="title">FindALVex</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;G.vexnum)<span class="comment">//找不到</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">return</span> G.vertices[i].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建无向图 以邻接表存储</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">EdgeType value;</span><br><span class="line">VertexType v1,v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input vexnum and arcnum:"</span>);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;G.vexnum,&amp;G.arcnum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %d vexs:"</span>,i+<span class="number">1</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;G.vertices[i].data);<span class="comment">//输入顶点标识符</span></span><br><span class="line">G.vertices[i].first = <span class="literal">NULL</span>;<span class="comment">//初始化第一个邻接结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.arcnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input v1 v2 and value:"</span>);<span class="comment">//输入顶点间的边权值</span></span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %c%d"</span>,&amp;v1,&amp;v2,&amp;value);</span><br><span class="line">x = LocateALVex(G,v1);<span class="comment">//找到顶点标识在顶点表的位置</span></span><br><span class="line">y = LocateALVex(G,v2);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">-1</span>||y==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error v1 or v2\n"</span>);<span class="comment">//找不到顶点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">SetNeighbor(G,x,y,value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowALGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--AdjList-----ArchNode:\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d [%c,]-----"</span>,i,FindALVex(G,i));<span class="comment">//输出顶点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个邻接点下标，不小于0即可，找下一个邻接点下标（最后结束返回-1）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,i); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,i,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;[%d,w=%d]"</span>,k,GetWeight(G,i,k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求G图中顶点x的第一个邻接点，返回顶点号，若没有或不存在x，返回-1 or -2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FistNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; G.vexnum)<span class="comment">//找不到x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(G.vertices[x].first==<span class="literal">NULL</span>)<span class="comment">//没有邻接结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">return</span> G.vertices[x].first-&gt;adjvex;<span class="comment">//返回第一个邻接点的顶点表下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是最后一个，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ArchNode *tmp = G.vertices[x].first;</span><br><span class="line"><span class="keyword">if</span>(x&gt;G.vexnum || y&gt;G.vexnum)<span class="comment">//找不到x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(G.vertices[x].first==<span class="literal">NULL</span>)<span class="comment">//没有邻接结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)<span class="comment">//若y是邻接边结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==tmp-&gt;adjvex &amp;&amp; tmp-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//除y之外顶点x的下一个邻接点</span></span><br><span class="line"><span class="keyword">return</span> tmp-&gt;next-&gt;adjvex;</span><br><span class="line">tmp = tmp-&gt;next;<span class="comment">//找下一个边结点，找到为止</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取权值</span></span><br><span class="line"><span class="function">EdgeType <span class="title">GetWeight</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ArchNode *tmp = G.vertices[x].first;</span><br><span class="line"><span class="keyword">if</span>(x&gt;G.vexnum || y&gt;G.vexnum)<span class="comment">//找不到x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(G.vertices[x].first==<span class="literal">NULL</span>)<span class="comment">//没有邻接结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)<span class="comment">//若y是邻接边结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==tmp-&gt;adjvex)<span class="comment">//返回x与y之间的权值</span></span><br><span class="line"><span class="keyword">return</span> tmp-&gt;weight;</span><br><span class="line">tmp = tmp-&gt;next;<span class="comment">//找下一个边结点，找到为止</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置邻接点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNeighbor</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ArchNode *p1,*p2;</span><br><span class="line">p1 = <span class="keyword">new</span> ArchNode(); <span class="comment">//v1的第一个邻接点p1</span></span><br><span class="line">p1-&gt;adjvex = y;<span class="comment">//p1保存y在顶点表下标</span></span><br><span class="line">p1-&gt;weight = value;<span class="comment">//设置权值</span></span><br><span class="line">p1-&gt;next = G.vertices[x].first;<span class="comment">//p1接在v1后面</span></span><br><span class="line">G.vertices[x].first = p1;</span><br><span class="line"><span class="comment">//无向图</span></span><br><span class="line">p2 = <span class="keyword">new</span> ArchNode(); <span class="comment">//v2的第一个邻接点p2</span></span><br><span class="line">p2-&gt;adjvex = x;<span class="comment">//p1保存x在顶点表下标</span></span><br><span class="line">p2-&gt;weight = value;<span class="comment">//设置权值</span></span><br><span class="line">p2-&gt;next = G.vertices[y].first;<span class="comment">//p2接在v2后面</span></span><br><span class="line">G.vertices[y].first = p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表转换邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> arcs[MaxVertexNum][MaxVertexNum])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,i); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,i,k))</span><br><span class="line">&#123;</span><br><span class="line">arcs[i][k] = GetWeight(G,i,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];<span class="comment">//用于搜索的访问数组</span></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[j])</span><br><span class="line">DFS(G,j);<span class="comment">//若未被访问，则向下访问</span></span><br><span class="line"><span class="comment">//若已经访问，则循环下一个分量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索（从顶点出发，递归操作，类似树的先序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(G,v);<span class="comment">//访问操作</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//已访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,v); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,v,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[k])<span class="comment">//若邻接点没有访问，优先访问邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索（非递归操作）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Non_RC</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从顶点v开始，进行深度优先搜索，一次遍历一个连通分类</span></span><br><span class="line"><span class="keyword">int</span> i,w,k;<span class="comment">//顶点序号</span></span><br><span class="line">SqStack S;</span><br><span class="line">InitSqStack(S);<span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"></span><br><span class="line">PushSqStack(S,v);<span class="comment">//进栈就访问结点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!isEmptySqStack(S))</span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S,k);</span><br><span class="line">visit(G,k);</span><br><span class="line"><span class="keyword">for</span> (w=FistNeighbor(G,k); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,k,w))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[w])</span><br><span class="line">&#123;</span><br><span class="line">PushSqStack(S,w);</span><br><span class="line">visited[w] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, FindALVex(G,v));<span class="comment">//输出顶点标识符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue Q;<span class="comment">//全局</span></span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">intiQueue(Q);<span class="comment">//需要辅助队列</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[j])</span><br><span class="line">BFS(G,j);<span class="comment">//若未被访问，则向下访问</span></span><br><span class="line"><span class="comment">//若已经访问，则循环下一个分量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索（由顶点出发，需要辅助队列，类似树的层序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(G,v);<span class="comment">//进队前直接访问</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;</span><br><span class="line">inQueue(Q,v);<span class="comment">//进队，进的是顶点下标</span></span><br><span class="line"><span class="keyword">while</span>(!isEmptyQueue(Q))</span><br><span class="line">&#123;</span><br><span class="line">v = outQueue(Q);<span class="comment">//出队找邻接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,v); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,v,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[k])<span class="comment">//访问所有未被访问的邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">visit(G,k);</span><br><span class="line">visited[k] = <span class="literal">true</span>;</span><br><span class="line">inQueue(Q,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">destroyQueue(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mgraph-c"><a href="#mgraph-c" class="headerlink" title="mgraph.c"></a>mgraph.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mgraph.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//无向图undirected graph，有向图directed graph</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//找到顶点标识在顶点表的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == G.Vex[i])&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过下标找到顶点标识</span></span><br><span class="line"><span class="function">VertexType <span class="title">FindVex</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;G.vexnum)<span class="comment">//找不到</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">return</span> G.Vex[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建无向图 以邻接矩阵存储</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateUDG</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">EdgeType value;</span><br><span class="line">VertexType v1,v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input vexnum and arcnum:"</span>);<span class="comment">//输入顶点数和弧数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;G.vexnum,&amp;G.arcnum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//输入顶点标识</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %d vexs:"</span>,i+<span class="number">1</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;G.Vex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)<span class="comment">//初始化矩阵，全部初始化为无穷值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; ++k)</span><br><span class="line">&#123;</span><br><span class="line">G.Edge[j][k] = MaxInt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.arcnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input v1 v2 and value:"</span>);<span class="comment">//输入顶点间的边权值</span></span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %c%d"</span>,&amp;v1,&amp;v2,&amp;value);</span><br><span class="line">x = LocateVex(G,v1);<span class="comment">//找到顶点标识在顶点表的位置</span></span><br><span class="line">y = LocateVex(G,v2);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">-1</span>||y==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error v1 or v2\n"</span>);<span class="comment">//找不到顶点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">G.Edge[x][y] = value;</span><br><span class="line">G.Edge[y][x] = G.Edge[x][y];<span class="comment">//无向图是对称矩阵</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMGraph</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----MatrixGraph:\n  "</span>);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vexnum; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c   "</span>,G.Vex[k]);<span class="comment">//输出行顶点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, G.Vex[i]);<span class="comment">//输出列顶点</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.Edge[i][j]==MaxInt)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c   "</span>,<span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d   "</span>, G.Edge[i][j]);<span class="comment">//全部输出连接矩阵的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在边 &lt;x,y&gt;,有返回true，无返回flase</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Adjacent</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (G.Edge[x][y] == MaxInt)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列出G图与顶点x相邻的边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Neighbors</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"'%c' have edges: \n"</span>,FindVex(G,x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Adjacent(G,x,i))<span class="comment">//有权值，即有边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;%c,%c&gt; value=%d\n"</span>,FindVex(G,x),FindVex(G,i),G.Edge[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertVertex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(LocateVex(G,v)!=<span class="number">-1</span>)<span class="comment">//该结点已存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">G.Vex[G.vexnum] = v;<span class="comment">//加入顶点表</span></span><br><span class="line">G.vexnum++;<span class="comment">//数量+1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum<span class="number">-1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">G.Edge[i][G.vexnum<span class="number">-1</span>] = MaxInt;<span class="comment">//初始化先前存在的顶点 Vex[旧结点][新结点]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line">G.Edge[G.vexnum<span class="number">-1</span>][j] = MaxInt;<span class="comment">//初始化新结点一整行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteVertex</span><span class="params">(MatrixGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(LocateVex(G,v)==<span class="number">-1</span>)<span class="comment">//该结点不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = LocateVex(G,v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; G.vexnum; ++i)<span class="comment">//删除顶点表的结点v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span> == G.vexnum)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//若v是最后一点，直接忽略即可</span></span><br><span class="line">G.Vex[i] = G.Vex[i+<span class="number">1</span>];<span class="comment">//v后面的顶点顶上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; G.vexnum; ++j)<span class="comment">//删除邻接矩阵的行数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j+<span class="number">1</span> == G.vexnum)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//若v是最后一点，直接忽略即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.vexnum; ++k)</span><br><span class="line">&#123;</span><br><span class="line">G.Edge[j][k] = G.Edge[j+<span class="number">1</span>][k];<span class="comment">//v后面的数据顶上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; G.vexnum; ++j)<span class="comment">//删除邻接矩阵的列数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j+<span class="number">1</span> == G.vexnum)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//若v是最后一点，直接忽略即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.vexnum; ++k)</span><br><span class="line">&#123;</span><br><span class="line">G.Edge[k][j] = G.Edge[k][j+<span class="number">1</span>];<span class="comment">//v后面的数据顶上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G.vexnum--;<span class="comment">//结点数量-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若&lt;x,y&gt;不存在边，则在两个顶点之间插入边,若是无权图,v直接设置为MaxInt</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddEdge</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!Adjacent(G,x,y))<span class="comment">//&lt;x,y&gt;不存在边</span></span><br><span class="line">&#123;</span><br><span class="line">SetEdgeValue(G,x,y,v);<span class="comment">//set value</span></span><br><span class="line">SetEdgeValue(G,y,x,v);</span><br><span class="line">G.arcnum++;<span class="comment">//弧数（边数）+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//存在边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若&lt;x,y&gt;存在边，则删除边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoveEdge</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Adjacent(G,x,y))<span class="comment">//&lt;x,y&gt;存在边</span></span><br><span class="line">&#123;</span><br><span class="line">SetEdgeValue(G,x,y,MaxInt);<span class="comment">//赋予无穷大即是删除边</span></span><br><span class="line">SetEdgeValue(G,y,x,MaxInt);</span><br><span class="line">G.arcnum--;<span class="comment">//弧数（边数）-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不存在边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求G图中顶点x的第一个邻接点，返回顶点下标，若没有或不存在x，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FistNeighbor</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Adjacent(G,x,i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回第一个邻接点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是最后一个，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextNeighbor</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Adjacent(G,x,y) &amp;&amp; i &gt; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回 续y之后的 下一个邻接点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取&lt;x,y&gt;权值</span></span><br><span class="line"><span class="function">EdgeType <span class="title">GetEdgeValue</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> G.Edge[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置&lt;x,y&gt;权值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetEdgeValue</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> x,<span class="keyword">int</span> y,EdgeType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G.Edge[x][y] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> mVisited[MaxVertexNum];<span class="comment">//用于搜索的访问数组</span></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">mVisited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mVisited[j])</span><br><span class="line">DFS(G,j);<span class="comment">//若未被访问，则向下访问</span></span><br><span class="line"><span class="comment">//若已经访问，则循环下一个分量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索（从顶点出发，递归操作，类似树的先序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(G,v);<span class="comment">//访问操作</span></span><br><span class="line">mVisited[v] = <span class="literal">true</span>;<span class="comment">//已访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,v); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,v,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mVisited[k])<span class="comment">//若邻接点没有访问，优先访问邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索（非递归操作）(//由于使用了栈。所以会先输出边结点右边开始)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Non_RC</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从顶点v开始，进行深度优先搜索，一次遍历一个连通分类</span></span><br><span class="line"><span class="keyword">int</span> i,w,k;<span class="comment">//顶点序号</span></span><br><span class="line">SqStack S;</span><br><span class="line">InitSqStack(S);<span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">mVisited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"></span><br><span class="line">PushSqStack(S,v);<span class="comment">//进栈就访问结点</span></span><br><span class="line">mVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!isEmptySqStack(S))</span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S,k);</span><br><span class="line">visit(G,k);</span><br><span class="line"><span class="keyword">for</span> (w=FistNeighbor(G,k); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,k,w))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mVisited[w])</span><br><span class="line">&#123;</span><br><span class="line">PushSqStack(S,w);</span><br><span class="line">mVisited[w] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, FindVex(G,v));<span class="comment">//输出顶点标识符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue mQ;<span class="comment">//全局</span></span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">intiQueue(mQ);<span class="comment">//需要辅助队列</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">mVisited[i] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mVisited[j])</span><br><span class="line">BFS(G,j);<span class="comment">//若未被访问，则向下访问</span></span><br><span class="line"><span class="comment">//若已经访问，则循环下一个分量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索（由顶点出发，需要辅助队列，类似树的层序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(G,v);<span class="comment">//进队前直接访问</span></span><br><span class="line">mVisited[v] = <span class="literal">true</span>;</span><br><span class="line">inQueue(mQ,v);<span class="comment">//进队，进的是顶点下标</span></span><br><span class="line"><span class="keyword">while</span>(!isEmptyQueue(mQ))</span><br><span class="line">&#123;</span><br><span class="line">v = outQueue(mQ);<span class="comment">//出队找邻接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,v); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,v,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mVisited[k])<span class="comment">//访问所有未被访问的邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">visit(G,k);</span><br><span class="line">mVisited[k] = <span class="literal">true</span>;</span><br><span class="line">inQueue(mQ,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">destroyQueue(mQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MaxInt];</span><br><span class="line"><span class="comment">//广度优先搜索求最短路径(适合无权图)（邻接表的算法一样）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">mVisited[j] = <span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">d[i] = MaxInt;<span class="comment">//初始化路径数组</span></span><br><span class="line"></span><br><span class="line">mVisited[u] = <span class="literal">true</span>;<span class="comment">//对u操作</span></span><br><span class="line">d[u] = <span class="number">0</span>;</span><br><span class="line">intiQueue(mQ);</span><br><span class="line">inQueue(mQ,u);</span><br><span class="line"><span class="keyword">while</span>(!isEmptyQueue(mQ))</span><br><span class="line">&#123;</span><br><span class="line">u = outQueue(mQ);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,u); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,u,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mVisited[k])<span class="comment">//访问所有未被访问的邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">mVisited[k] = <span class="literal">true</span>;</span><br><span class="line">d[k] = d[u]+<span class="number">1</span>;</span><br><span class="line">inQueue(mQ,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">destroyQueue(mQ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowDistance</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, FindVex(G,i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, d[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断这个图是不是树（树是一个特殊的图）</span></span><br><span class="line"><span class="comment">//若G是一个无回路的连通图或者有n-1条边的连通图</span></span><br><span class="line"><span class="comment">//一次深度遍历就能访问n个顶点，n-1条边，则可以判定是一棵树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTree</span><span class="params">(MatrixGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">mVisited[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> Vnum=<span class="number">0</span>,Enum=<span class="number">0</span>;</span><br><span class="line">DFS_Is_Tree(G,<span class="number">0</span>,Vnum,Enum);</span><br><span class="line"><span class="comment">// printf("|%d %d\n",Vnum,Enum );</span></span><br><span class="line"><span class="comment">// 算法没错，但是 递归+第一邻接点和下一个邻接点，就有些矛盾了，</span></span><br><span class="line"><span class="comment">// 所以Enum次数不是2(n-1)次</span></span><br><span class="line"><span class="comment">// 或许用非递归会比较好</span></span><br><span class="line"><span class="keyword">if</span> (Vnum==G.vexnum &amp;&amp; Enum==<span class="number">2</span>*(G.vexnum<span class="number">-1</span>))<span class="comment">//因为是递归所以是2(n-1)次</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造的深度搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Is_Tree</span><span class="params">(MatrixGraph &amp;G,<span class="keyword">int</span> v,<span class="keyword">int</span> &amp;Vnum,<span class="keyword">int</span> &amp;Enum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mVisited[v] = <span class="literal">true</span>;</span><br><span class="line">Vnum++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=FistNeighbor(G,v); k&gt;=<span class="number">0</span>; k=NextNeighbor(G,v,k))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf("%d ", k);</span></span><br><span class="line">Enum++;</span><br><span class="line"><span class="comment">//printf("%d ", Enum);</span></span><br><span class="line"><span class="keyword">if</span> (!mVisited[k])<span class="comment">//若邻接点没有访问，优先访问邻接点</span></span><br><span class="line">&#123;</span><br><span class="line">DFS_Is_Tree(G,k,Vnum,Enum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-图&quot;&gt;&lt;a href=&quot;#数据结构-图&quot; class=&quot;headerlink&quot; title=&quot;数据结构 图&quot;&gt;&lt;/a&gt;数据结构 图&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_bitree</title>
    <link href="http://yoursite.com/2018/12/26/struct-bitree/"/>
    <id>http://yoursite.com/2018/12/26/struct-bitree/</id>
    <published>2018-12-26T06:05:19.000Z</published>
    <updated>2018-12-26T06:16:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-二叉树"><a href="#数据结构-二叉树" class="headerlink" title="数据结构 二叉树"></a>数据结构 二叉树</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T, ElemType Data,<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelPrintBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Width</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderByStack</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderByStack1</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderByStack2</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderByStack</span><span class="params">(BiTree T)</span></span>; </span><br><span class="line"><span class="function">BiTree <span class="title">GetTreeNode</span><span class="params">(ElemType item,BiTNode *l,BiTNode *r)</span></span>;</span><br><span class="line"><span class="function">BiTree <span class="title">CopyTree</span><span class="params">(BiTNode *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTree QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType *base;<span class="comment">//存储空间基地址</span></span><br><span class="line"><span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;queueBiTree;<span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intiQueueBitTree</span><span class="params">(queueBiTree &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inQueue</span><span class="params">(queueBiTree &amp;Q, QElemType e)</span></span>;</span><br><span class="line"><span class="function">QElemType <span class="title">outQueue</span><span class="params">(queueBiTree &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptyQueue</span><span class="params">(queueBiTree &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyQueue</span><span class="params">(queueBiTree &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queueLenght</span><span class="params">(queueBiTree &amp;Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTree SElemType;</span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptySqStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushSqStack</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopSqStack</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="tree-c"><a href="#tree-c" class="headerlink" title="tree.c"></a>tree.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T, ElemType Data,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//index=0代表根节点，1表示左子树结点，2表示右子树结点</span></span><br><span class="line"><span class="keyword">char</span> data = Data;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="string">'#'</span>)<span class="comment">//在循环中，输错重新输入</span></span><br><span class="line">&#123;</span><br><span class="line">data = Data;<span class="comment">//输入错误时，修正data值</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input root :"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %c to left child :"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input %c to right child :"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;data);</span><br><span class="line"><span class="keyword">if</span> (data != <span class="string">'#'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data &gt;= <span class="string">'a'</span> &amp;&amp; data &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">T = <span class="keyword">new</span> BiTNode();</span><br><span class="line">T-&gt;data = data;</span><br><span class="line">T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">CreateBiTree(T-&gt;lchild, T-&gt;data, <span class="number">1</span>);    <span class="comment">//子树，父亲节点的值，标识</span></span><br><span class="line">CreateBiTree(T-&gt;rchild, T-&gt;data, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Not in range 'a-z'\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">DestroyBiTree(T-&gt;lchild);   <span class="comment">//销毁左子树</span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">DestroyBiTree(T-&gt;rchild);   <span class="comment">//销毁右子树</span></span><br><span class="line"><span class="keyword">delete</span> T;   <span class="comment">//销毁根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, T-&gt;data);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) </span><br><span class="line">&#123;</span><br><span class="line">InOrderTraverse(T-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, T-&gt;data);</span><br><span class="line">InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) </span><br><span class="line">&#123;</span><br><span class="line">PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">PostOrderTraverse(T-&gt;rchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树不为空，则有4种情况：</span></span><br><span class="line"><span class="comment">1、如果一棵树只有一个结点，他的深度为1</span></span><br><span class="line"><span class="comment">2、如果根结点只有左子树而没有右子树，那么二叉树的深度应该是其左子树的深度加1</span></span><br><span class="line"><span class="comment">3、如果根结点只有右子树而没有左子树，那么二叉树的深度应该是其右子树的深度加1</span></span><br><span class="line"><span class="comment">4、如果根结点既有左子树又有右子树，那么二叉树深度应该是其左右子树的深度较大值加1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line"><span class="keyword">return</span> Depth(T-&gt;lchild)&gt;Depth(T-&gt;rchild) ? Depth(T-&gt;lchild)+<span class="number">1</span>:Depth(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelPrintBiTree</span><span class="params">(BiTree &amp;T)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QElemType BT;           <span class="comment">//tmp结点</span></span><br><span class="line">queueBiTree Q;</span><br><span class="line">intiQueueBitTree(Q);    <span class="comment">//初始化一个新队列</span></span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">&#123;</span><br><span class="line">inQueue(Q, T);      <span class="comment">//把根节点进队</span></span><br><span class="line"><span class="keyword">while</span> (!isEmptyQueue(Q))</span><br><span class="line">&#123;</span><br><span class="line">BT = outQueue(Q);<span class="comment">//出队一个</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, BT-&gt;data);  <span class="comment">//每输出结点的data，就把结点的左右子树入队</span></span><br><span class="line"><span class="keyword">if</span> (BT-&gt;lchild)</span><br><span class="line">inQueue(Q, BT-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (BT-&gt;rchild)</span><br><span class="line">inQueue(Q, BT-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">destroyQueue(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的宽度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Width</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nLastLevelWidth = <span class="number">0</span>;    <span class="comment">//记录上一层的宽度  </span></span><br><span class="line"><span class="keyword">int</span> nTempLastLevelWidth = <span class="number">0</span>;<span class="comment">//暂时值(上一层的宽度)  </span></span><br><span class="line"><span class="keyword">int</span> nCurLevelWidth = <span class="number">0</span>;     <span class="comment">//记录当前层的宽度  </span></span><br><span class="line"><span class="keyword">int</span> nWidth = <span class="number">1</span>;             <span class="comment">//二叉树的宽度  </span></span><br><span class="line"></span><br><span class="line">queueBiTree myQueue;</span><br><span class="line">intiQueueBitTree(myQueue);  <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line">inQueue(myQueue,T);         <span class="comment">//将根节点入队列  </span></span><br><span class="line">nLastLevelWidth = <span class="number">1</span>;        <span class="comment">//记录层数    </span></span><br><span class="line">QElemType pCur = <span class="literal">NULL</span>;      <span class="comment">//用于存入出队的结点</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> (!isEmptyQueue(myQueue))<span class="comment">//队列不空  </span></span><br><span class="line">&#123;  </span><br><span class="line">nTempLastLevelWidth = nLastLevelWidth;  </span><br><span class="line"><span class="keyword">while</span> (nTempLastLevelWidth != <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">pCur = outQueue(myQueue);<span class="comment">//出队列,并且得到头元素,</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;lchild != <span class="literal">NULL</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">inQueue(myQueue,pCur-&gt;lchild);  <span class="comment">//左子树入队</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;rchild != <span class="literal">NULL</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">inQueue(myQueue,pCur-&gt;rchild);  <span class="comment">//右子树入队</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">nTempLastLevelWidth--;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">nCurLevelWidth = queueLenght(myQueue);  <span class="comment">//得到队列长度</span></span><br><span class="line">nWidth = nCurLevelWidth &gt; nWidth ? nCurLevelWidth : nWidth;  </span><br><span class="line">nLastLevelWidth = nCurLevelWidth;  </span><br><span class="line">&#125;  </span><br><span class="line">    destroyQueue(myQueue);</span><br><span class="line"><span class="keyword">return</span> nWidth;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归遍历 需要考虑什么时候访问结点（出栈还是进栈）</span></span><br><span class="line"><span class="comment">//非递归的中序遍历（只有一次进栈出栈，在出栈访问则是中序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderByStack</span><span class="params">(BiTree T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">InitSqStack(S);<span class="comment">//初始化辅助栈</span></span><br><span class="line">BiTree p = T;<span class="comment">//遍历指针</span></span><br><span class="line"><span class="keyword">while</span>(p||!isEmptySqStack(S))<span class="comment">//栈不空，p不空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">PushSqStack(S,p);<span class="comment">//遇到非空二叉树，走左</span></span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S,p);<span class="comment">//左边入栈完毕，遇到空栈则出栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;rchild;<span class="comment">//出栈后走右,当出栈最后一个元素，p=null，stack=null </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归的先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderByStack1</span><span class="params">(BiTree T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">SqStack S;</span><br><span class="line">InitSqStack(S);<span class="comment">//初始化辅助栈</span></span><br><span class="line">BiTree p = T;<span class="comment">//遍历指针</span></span><br><span class="line"></span><br><span class="line">PushSqStack(S,p);</span><br><span class="line"><span class="keyword">while</span>(!isEmptySqStack(S))</span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//根据栈的特性，先进右在进左</span></span><br><span class="line">PushSqStack(S,p-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">PushSqStack(S,p-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种解法，(只有一次进栈出栈，在进栈访问则是先序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderByStack2</span><span class="params">(BiTree T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">InitSqStack(S);<span class="comment">//初始化辅助栈</span></span><br><span class="line">BiTree p = T;<span class="comment">//遍历指针</span></span><br><span class="line"><span class="keyword">while</span>(p||!isEmptySqStack(S))<span class="comment">//栈不空，p不空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">PushSqStack(S,p);<span class="comment">//遇到非空二叉树，走左</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S,p);<span class="comment">//左边入栈完毕，遇到空栈则出栈</span></span><br><span class="line">p = p-&gt;rchild;<span class="comment">//出栈后走右,当出栈最后一个元素，p=null，stack=null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归的后序遍历（有2次进栈出栈，在第二次出栈访问则是后序遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderByStack</span><span class="params">(BiTree T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">SqStack S1,S2;</span><br><span class="line">InitSqStack(S1);<span class="comment">//初始化辅助栈</span></span><br><span class="line">InitSqStack(S2);</span><br><span class="line">BiTree p = T;<span class="comment">//遍历指针</span></span><br><span class="line"></span><br><span class="line">PushSqStack(S1,p);</span><br><span class="line"><span class="keyword">while</span>(!isEmptySqStack(S1))</span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S1,p);</span><br><span class="line">PushSqStack(S2,p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">PushSqStack(S1,p-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">PushSqStack(S1,p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!isEmptySqStack(S2))</span><br><span class="line">&#123;</span><br><span class="line">PopSqStack(S2,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function">BiTree <span class="title">GetTreeNode</span><span class="params">(ElemType item,BiTNode *l,BiTNode *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree T = <span class="keyword">new</span> BiTNode();</span><br><span class="line">T-&gt;data = item;</span><br><span class="line">T-&gt;lchild = l;</span><br><span class="line">T-&gt;rchild = r;</span><br><span class="line"><span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制二叉树</span></span><br><span class="line"><span class="function">BiTree <span class="title">CopyTree</span><span class="params">(BiTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode *newL,*newR;</span><br><span class="line">BiTree newT;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">newL = CopyTree(T-&gt;lchild);<span class="comment">//复制左子树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">newL = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">newR = CopyTree(T-&gt;rchild);<span class="comment">//复制右子树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">newR = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">newT = GetTreeNode(T-&gt;data,newL,newR);</span><br><span class="line"><span class="keyword">return</span> newT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stack-c"><a href="#stack-c" class="headerlink" title="stack.c"></a>stack.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptySqStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushSqStack</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MAXSIZE<span class="number">-1</span>)<span class="comment">//是否为满栈</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.data[++S.top] = e;<span class="comment">//栈顶指针先往上移，再赋值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopSqStack</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是否栈空</span></span><br><span class="line">e = S.data[S.top--];<span class="comment">//先出栈，指针减一</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="queue-c"><a href="#queue-c" class="headerlink" title="queue.c"></a>queue.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intiQueueBitTree</span><span class="params">(queueBiTree &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.base = <span class="keyword">new</span> QElemType[MAXSIZE];</span><br><span class="line"><span class="keyword">if</span>(!Q.base)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//分配失败</span></span><br><span class="line">Q.front = Q.rear = <span class="number">0</span>;<span class="comment">//必须初始化头尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inQueue</span><span class="params">(queueBiTree &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE != Q.front)<span class="comment">//队列没有满（进看满未满）</span></span><br><span class="line">&#123;</span><br><span class="line">Q.base[Q.rear] = e;<span class="comment">//插入队尾</span></span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">//队尾加1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="function">QElemType <span class="title">outQueue</span><span class="params">(queueBiTree &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QElemType e;</span><br><span class="line"><span class="keyword">if</span> (Q.front != Q.rear)<span class="comment">//队列不空（出看空不空）</span></span><br><span class="line">&#123;</span><br><span class="line">e = Q.base[Q.front];<span class="comment">//队头出队</span></span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;<span class="comment">//队头加1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptyQueue</span><span class="params">(queueBiTree &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyQueue</span><span class="params">(queueBiTree &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.base)</span><br><span class="line"><span class="keyword">delete</span> Q.base;</span><br><span class="line"></span><br><span class="line">Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queueLenght</span><span class="params">(queueBiTree &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//防止尾指针在头指针，然后出现负数</span></span><br><span class="line"><span class="keyword">return</span> (Q.rear + MAXSIZE - Q.front) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-二叉树&quot;&gt;&lt;a href=&quot;#数据结构-二叉树&quot; class=&quot;headerlink&quot; title=&quot;数据结构 二叉树&quot;&gt;&lt;/a&gt;数据结构 二叉树&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_link</title>
    <link href="http://yoursite.com/2018/12/26/struct-link/"/>
    <id>http://yoursite.com/2018/12/26/struct-link/</id>
    <published>2018-12-26T06:02:34.000Z</published>
    <updated>2018-12-26T06:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构 链表"></a>数据结构 链表</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">CreateLinkByHead</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">LinkList <span class="title">CreateLinkBNyTail</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function">LNode * <span class="title">GetElemByIndex</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function">LNode * <span class="title">GetElemByValue</span><span class="params">(LinkList &amp;L,ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLink</span><span class="params">(LinkList &amp;L,ElemType e,<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLNode</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">// bool SwapLNode(LNode A,LNode B);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Same_x</span><span class="params">(LinkList &amp;L,ElemType x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Same_x_1</span><span class="params">(LinkList &amp;L,ElemType x)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"link.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">CreateLinkByHead</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *tmp;<span class="comment">//中间结点</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">L = <span class="keyword">new</span> LNode;<span class="comment">//头结点，不存值</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">9999</span>)<span class="comment">//输入9999你表示结束</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> LNode;</span><br><span class="line">tmp-&gt;data = x;</span><br><span class="line">tmp-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = tmp;<span class="comment">//插入新节点，L仍是头结点</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//最终顺序是输入的倒序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法（需要一个尾指针）</span></span><br><span class="line"><span class="function">LinkList <span class="title">CreateLinkBNyTail</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">L = <span class="keyword">new</span> LNode;<span class="comment">//头结点</span></span><br><span class="line">LNode *tmp, *tail = L;<span class="comment">//刚开始尾指针指向头结点</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> LNode;</span><br><span class="line">tmp-&gt;data = x;</span><br><span class="line">tail-&gt;next = tmp;</span><br><span class="line">tail = tmp;<span class="comment">//尾指针指向每次插入的新结点</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾结点的next指向null</span></span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找i位置的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElemByIndex</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;<span class="comment">//计数由1开始</span></span><br><span class="line">LNode *p = L-&gt;next;<span class="comment">//L只是头结点，不存值，L-&gt;next是第一个值</span></span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//直接返回头结点</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; index&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//跳出循环则找到该结点，若i大于表长,p=NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查询结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElemByValue</span><span class="params">(LinkList &amp;L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//找到返回该结点，否则NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前插法，将e插入到index位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertLink</span><span class="params">(LinkList &amp;L,ElemType e,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">LNode *n = <span class="keyword">new</span> LNode;</span><br><span class="line">n-&gt;data = e;</span><br><span class="line"><span class="comment">//先找到index-1结点，即是新解点的前驱</span></span><br><span class="line">LNode *p = GetElemByIndex(L,index<span class="number">-1</span>);</span><br><span class="line">n-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = n;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteLNode</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *p = GetElemByIndex(L,index<span class="number">-1</span>);<span class="comment">//删除点的前驱</span></span><br><span class="line">LNode *q = p-&gt;next;<span class="comment">//删除点</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *n = L-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no link\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,n-&gt;data);</span><br><span class="line">n = n-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *n,*f,*x,*y;</span><br><span class="line"></span><br><span class="line">f = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span> || L-&gt;next-&gt;next == <span class="literal">NULL</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no link or not enough LNode\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(L-&gt;next-&gt;next != f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次循环都将最大的数置后</span></span><br><span class="line"><span class="keyword">for</span>(n = L;n-&gt;next-&gt;next != f;n=n-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n-&gt;next-&gt;data &gt; n-&gt;next-&gt;next-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// SwapLNode(n-&gt;next,n-&gt;next-&gt;next);</span></span><br><span class="line">x = n-&gt;next;</span><br><span class="line">y = n-&gt;next-&gt;next;</span><br><span class="line">n-&gt;next = y;</span><br><span class="line">x-&gt;next = y-&gt;next;</span><br><span class="line">y-&gt;next = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f = n-&gt;next;<span class="comment">//记录最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除相同x（L不含头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Same_x</span><span class="params">(LinkList &amp;L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *tmp;</span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line">tmp = L;</span><br><span class="line">L = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">Del_Same_x(L,x);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Del_Same_x(L-&gt;next,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除相同x（L含头结点，x不唯一）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Same_x_1</span><span class="params">(LinkList &amp;L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *p = L-&gt;next, *pre = L, *tmp;<span class="comment">//置p和pre的初始值,pre是前驱</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line">tmp = p;</span><br><span class="line">p = tmp-&gt;next;</span><br><span class="line">pre-&gt;next = p;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pre = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//逆序结点(也可以用递归或者栈直接输出)</span></span><br><span class="line"><span class="function">LinkList <span class="title">Reverse</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *tmp, *p = L-&gt;next, *r = p-&gt;next;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//处理第一个结点,变为末结点，</span></span><br><span class="line"><span class="keyword">while</span>(r!=<span class="literal">NULL</span>)<span class="comment">//r为空，则说明p为最后的一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = p;</span><br><span class="line">p = r;<span class="comment">//依次继续遍历</span></span><br><span class="line">r = r-&gt;next;</span><br><span class="line">p-&gt;next = tmp;<span class="comment">//指针反转</span></span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next = p;<span class="comment">//处理最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最小值（最小值唯一）</span></span><br><span class="line"><span class="function">LinkList <span class="title">DeleteLMini</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *pre = L,*p = pre-&gt;next;<span class="comment">//需要结点和前驱结点</span></span><br><span class="line">LNode *minper = pre,*minp = p;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data&lt;minp-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">minp = p;</span><br><span class="line">minper = pre;</span><br><span class="line">&#125;</span><br><span class="line">pre = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">minper-&gt;next = minp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> minp;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-链表&quot;&gt;&lt;a href=&quot;#数据结构-链表&quot; class=&quot;headerlink&quot; title=&quot;数据结构 链表&quot;&gt;&lt;/a&gt;数据结构 链表&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_queue</title>
    <link href="http://yoursite.com/2018/12/26/struct-queue/"/>
    <id>http://yoursite.com/2018/12/26/struct-queue/</id>
    <published>2018-12-26T05:59:45.000Z</published>
    <updated>2018-12-26T06:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-队列"><a href="#数据结构-队列" class="headerlink" title="数据结构 队列"></a>数据结构 队列</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//(顺序)循环队列（逻辑上看成一个环）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MaxSize];  <span class="comment">//存放队列元素</span></span><br><span class="line"><span class="keyword">int</span> front,rear; <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.rear = Q.front = <span class="number">0</span>;<span class="comment">//初始化队首、队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="comment">//队空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear+<span class="number">1</span>) % MaxSize == Q.front)<span class="comment">//队满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Q.data[Q.rear] = x;<span class="comment">//入队加进队尾</span></span><br><span class="line">Q.rear = (Q.rear+<span class="number">1</span>) % MaxSize;<span class="comment">//队尾指针+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="comment">//队空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = Q.data[Q.front];<span class="comment">//队首出队</span></span><br><span class="line">Q.front = (Q.front+<span class="number">1</span>) % MaxSize; <span class="comment">//队首+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MaxSize) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span> (!isEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (DeQueue(Q,e))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-队列&quot;&gt;&lt;a href=&quot;#数据结构-队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构 队列&quot;&gt;&lt;/a&gt;数据结构 队列&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>struct_stack</title>
    <link href="http://yoursite.com/2018/12/26/struct-stack/"/>
    <id>http://yoursite.com/2018/12/26/struct-stack/</id>
    <published>2018-12-26T05:53:12.000Z</published>
    <updated>2018-12-27T03:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-堆栈"><a href="#数据结构-堆栈" class="headerlink" title="数据结构 堆栈"></a>数据结构 堆栈</h1><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50<span class="comment">//栈中元素最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> * <span class="title">next</span>;</span> </span><br><span class="line">&#125;LinkNode,*LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptySqStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushSqStack</span><span class="params">(SqStack &amp;S,ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopSqStack</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopSqStack</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowSqStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkStack</span><span class="params">(LinkStack &amp;S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushLinkStack</span><span class="params">(LinkStack &amp;S,ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopLinkStack</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopLinkStack</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowLinkStack</span><span class="params">(LinkStack &amp;S)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptySqStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PushSqStack</span><span class="params">(SqStack &amp;S,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize<span class="number">-1</span>)<span class="comment">//是否为满栈</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.data[++S.top] = e;<span class="comment">//栈顶指针先往上移，再赋值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopSqStack</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是否栈空</span></span><br><span class="line">e = S.data[S.top--];<span class="comment">//先出栈，指针减一</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取顺序栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopSqStack</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是否栈空</span></span><br><span class="line">e = S.data[S.top];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示顺序栈中元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowSqStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------SqStack-------\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (PopSqStack(S,e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 链栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S = <span class="keyword">new</span> LinkNode;<span class="comment">//头结点</span></span><br><span class="line">S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈 进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushLinkStack</span><span class="params">(LinkStack &amp;S,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//链栈一般无栈满情况</span></span><br><span class="line">LinkNode *node = <span class="keyword">new</span> LinkNode;</span><br><span class="line">node-&gt;data = e;<span class="comment">//新建结点</span></span><br><span class="line">node-&gt;next = S-&gt;next;<span class="comment">//拼接头结点</span></span><br><span class="line">S-&gt;next = node;<span class="comment">//头插入 头结点后驱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopLinkStack</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode *node = S-&gt;next;</span><br><span class="line">e = node-&gt;data;</span><br><span class="line">S-&gt;next = node-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取链栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTopLinkStack</span><span class="params">(LinkStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = S-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链栈中元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowLinkStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------LinkStack-------\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (PopLinkStack(S,e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-堆栈&quot;&gt;&lt;a href=&quot;#数据结构-堆栈&quot; class=&quot;headerlink&quot; title=&quot;数据结构 堆栈&quot;&gt;&lt;/a&gt;数据结构 堆栈&lt;/h1&gt;&lt;h4 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring学习之注解篇（二）</title>
    <link href="http://yoursite.com/2017/08/25/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/25/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2017-08-25T11:30:03.000Z</published>
    <updated>2017-08-25T12:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring学习-之-Spring-AOP-注解"><a href="#Spring学习-之-Spring-AOP-注解" class="headerlink" title="Spring学习 之 Spring AOP 注解"></a>Spring学习 之 Spring AOP 注解</h2><hr><h4 id="＊AspectJ-注解"><a href="#＊AspectJ-注解" class="headerlink" title="＊AspectJ 注解"></a>＊AspectJ 注解</h4><ul><li>@AspectJ 的风格类似纯 Java 注册的普通 Java类</li><li>Spring 可以使用 AspectJ 来做切入点注解</li><li>AOP的运行时仍旧时纯的Spring AOP，对AspectJ 的编译器或者织入五依赖性</li><li>对@Aspect 可支持 XML或者 Java 风格的配置</li><li>拥有@Aspect的任何bean将被Spring自动识别并应用</li><li>用@Aspect注解的类可以有方法字段，他们也可以包括 Pointcut 切入点、Advice 通知、Introduction引入 的声明</li><li>一个类中的@Aspect注释表示它是一个切面，并且将自己从自动代理中排除</li><li><p>@Aspect注解时不能通过类路径自动检测发现的，所以需要配合使用@Component注解或者在xml配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.soloist.aop.aspectj"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Pointcut注解切入点——切入点表达式 通过 &amp;&amp;、||和 ！进行组合，也可以通过名字引用切入点表达式（通过组合可以建立更加复杂的切入点表达式（但不建议写太复杂，应该清晰明朗））</p></li><li><p>一个切入点通过一个普通方法定义来提供，@Pointcut注解，方法返回类型必须为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.soloist.aop.aspectj.biz.*Biz.*(..))"</span>)</span><br><span class="line"><span class="comment">//所有以Biz结尾的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.soloist.aop.aspectj.biz.*)"</span>)</span><br><span class="line"><span class="comment">//com.soloist.aop.aspectj.biz此包下的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bizPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MoocBiz save: "</span>+word);</span><br><span class="line">        <span class="comment">//throw new RuntimeException("Save failed");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Save success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义良好的 pointcut</p><ol><li>AspectJ是编译期的AOP</li><li>检查代码并匹配连接点于切入点的代价是昂贵的</li><li>一个好的切入点应该包括以下几点：<ul><li>选择特定类型的连接点，如：execution,get,set,call,handler</li><li>确定连接点范围，如：within,withincode</li><li>匹配上下文信息，如：this，target，@annotation</li></ul></li></ol></li><li><p>@Before</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.soloist.aop.aspectj.biz.*Biz.*(..))"</span>)</span><br><span class="line"><span class="comment">//所有以Biz结尾的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.soloist.aop.aspectj.biz.*)"</span>)</span><br><span class="line"><span class="comment">//com.soloist.aop.aspectj.biz此包下的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bizPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Before("execution(* com.soloist.aop.aspectj.biz.*Biz.*(..))")</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">//两种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@AfterReturning——指明切入点pointcut=”pointcut()”和返回值returning=”returnValue”</p></li><li>@AfterThrowing</li><li>@Around——第一个参数必须是ProceedingJoinPoint类型</li><li><p>@After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.soloist.aop.aspectj.biz.*Biz.*(..))"</span>)</span><br><span class="line">  <span class="comment">//所有以Biz结尾的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"within(com.soloist.aop.aspectj.biz.*)"</span>)</span><br><span class="line">  <span class="comment">//com.soloist.aop.aspectj.biz此包下的类中的所有方法，都会匹配当前切入点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bizPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Before("execution(* com.soloist.aop.aspectj.biz.*Biz.*(..))")</span></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">//两种方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//匹配pointcut，指定返回值（建议写Object类型，除非明确返回值类型）</span></span><br><span class="line">  <span class="meta">@AfterReturning</span>(pointcut=<span class="string">"pointcut()"</span>,returning=<span class="string">"returnValue"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"afterReturning: "</span>+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"pointcut()"</span>,throwing=<span class="string">"e"</span>)<span class="comment">//指定所抛出的异常</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">      e.printStackTrace(); <span class="comment">//将堆栈信息打印出来，作为调试使用</span></span><br><span class="line">      System.out.println(<span class="string">"afterThrowing: "</span>+e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"pointcutBefore"</span>);</span><br><span class="line">      Object obj = pjp.proceed();</span><br><span class="line">      System.out.println(<span class="string">"Around: "</span>+obj);<span class="comment">//接收参数</span></span><br><span class="line">      System.out.println(<span class="string">"pointcutAfter"</span>);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//finally advice 最终通知必须出路正常和异常两种返回结果，</span></span><br><span class="line">  <span class="comment">//通常用于释放资源(有点类似 try-catch-finally 中的finally的用途)</span></span><br><span class="line">  <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"finally advice"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Advice扩展</p><ol><li>携带参数</li><li>携带注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut() &amp;&amp; args(arg)"</span>)<span class="comment">//携带参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"BeforeWithParam: "</span>+arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut() &amp;&amp; @annotation(moocMethod)"</span>)<span class="comment">//携带注释</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithAnnotation</span><span class="params">(MoocMethod moocMethod)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"BeforeWithAnnotation: "</span>+moocMethod.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MoocMethod &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用自定义的注解去注解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="meta">@MoocMethod</span>(<span class="string">"@MoocMethod"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MoocBiz save: "</span>+word);</span><br><span class="line"><span class="comment">//throw new RuntimeException("Save failed");</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Save success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring学习-之-Spring-AOP-注解&quot;&gt;&lt;a href=&quot;#Spring学习-之-Spring-AOP-注解&quot; class=&quot;headerlink&quot; title=&quot;Spring学习 之 Spring AOP 注解&quot;&gt;&lt;/a&gt;Spring学习 之 Spr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring学习之基础篇（三）</title>
    <link href="http://yoursite.com/2017/08/24/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/24/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2017-08-24T04:33:28.000Z</published>
    <updated>2019-07-19T02:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring学习-之-AOP的基础"><a href="#Spring学习-之-AOP的基础" class="headerlink" title="Spring学习 之 AOP的基础"></a>Spring学习 之 AOP的基础</h2><hr><h4 id="＊xml配置一个简单的AOP"><a href="#＊xml配置一个简单的AOP" class="headerlink" title="＊xml配置一个简单的AOP"></a>＊xml配置一个简单的AOP</h4><ul><li><p>Spring所有的切面和通知器都必须放在一个&lt;aop:config&gt;内，可以配置包含多个&lt;aop:config&gt;元素，每一个&lt;aop:config&gt;可以包含pointcut、advisor、aspect元素（它们必须按照这个顺序先后声明）</p></li><li><p>正常情况：</p><p>  <img src="https://github.com/soloistben/images/raw/master/spring_image/1.png" alt="image" title="无异常"></p></li><li><p>异常情况：</p><p>  <img src="https://github.com/soloistben/images/raws/master/spring_image/2.png" alt="image" title="异常"></p></li><li><p>在 xml 配置的&lt;beans&gt;中添加AOP （左下角Namespace中添加aop）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 MyAspect作切面类 和 AspectBiz作业务类，将MyAspect类绑定&lt;aop:aspect&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.schema.advice.MyAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectBiz"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.schema.advice.biz.AspectBiz"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>元素&lt;aop:pointcut&gt;中expression属性表示作用范围</p><ul><li>AOP和SpringAOP都支持<ol><li>excution(public * *(..))    ——切入点为执行所有public方法</li><li>excution(* set*(..))——切入点为执行所有set开始的方法</li><li>excution(* com.xyz.service.AccountService.*(..)——切入点为执行AccountService类中的所有方法</li><li>excution(* com.xyz.service.*.*(..))——切入点为执行com.xyz.service包下的所有方法</li><li>excution(* com.xyz.service..*.*(..))——切入点为执行com.xyz.service包及其子包的所有方法</li></ol></li><li>只在SpringAOP支持<ol><li>within(com.xyz.service.*)</li><li>within(com.xyz.service..*)——within 用于匹配指定类型内的方法</li><li>this(com.xyz.service.AccountService)——this 用于匹配当前AOP代理对象类型的执行方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.soloist.aop.schema.advice.biz.*Biz.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>Before Advice 前置通知的配置——method对应的方法在MyAspect切面类中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.soloist.aop.schema.advice.biz.*Biz.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>After Returning Advice 返回后通知的配置</p></li><li><p>After-Throwing Advice 异常通知的配置</p></li><li><p>After Advice 后通知</p></li><li><p>Around Advice 环绕通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">执行切入点：</span></span><br><span class="line"><span class="comment">1、在com.soloist.aop.schema.advice.biz包下所有名称以Biz结尾的类中的所有方法都执行切入点，</span></span><br><span class="line"><span class="comment">2、每个切入点执行前都需要先执行 before 方法，</span></span><br><span class="line"><span class="comment">3、执行之后在执行 afterReturning 方法，</span></span><br><span class="line"><span class="comment">4、若抛出异常则会调用 afterThrowing 方法，并且不执行 afterReturning 方法（抛出异常则无法正常返回），</span></span><br><span class="line"><span class="comment">5、无论是否异常，都会在切入点之后执行 after 方法（与 before 方法相对）。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.soloist.aop.schema.advice.biz.*Biz.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturning"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>MyAspect声明相对的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.schema.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect_before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect_afterReturning"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect_afterThrowing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect_after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="comment">//环绕通知</span></span><br><span class="line">        System.out.println(<span class="string">"MyAspect_around111"</span>);<span class="comment">//在执行切入点之前执行</span></span><br><span class="line">        Object obj = pjp.proceed();<span class="comment">//切入点执行</span></span><br><span class="line">        System.out.println(<span class="string">"MyAspect_around222"</span>);<span class="comment">//在执行切入点之后执行</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AspectBiz 业务类所有方法都是切入点（测试：getBean 获得AspectBiz的bean实例，执行biz方法即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.schema.advice.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">biz</span><span class="params">()</span> </span>&#123;<span class="comment">//无参</span></span><br><span class="line">        System.out.println(<span class="string">"AspectBiz_biz"</span>);</span><br><span class="line">        <span class="comment">//throw new RuntimeException();//强行抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="＊Around-Advice可用于传递参数"><a href="#＊Around-Advice可用于传递参数" class="headerlink" title="＊Around Advice可用于传递参数"></a>＊Around Advice可用于传递参数</h4><ul><li><p>在xml配置另外设置&lt;aop:around&gt;元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.soloist.aop.schema.advice.biz.*Biz.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturning"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundInit"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.soloist.aop.schema.advice.biz.AspectBiz.init(String,int))</span></span></span><br><span class="line"><span class="tag"><span class="string">and args(bizName,times)"</span>/&gt;</span> --&gt;</span><br><span class="line"><span class="comment">&lt;!-- 这个around方法可以用于传参数,但在around中可以被修改 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>新建一个aroundInit方法 在MyAspect类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundInit</span><span class="params">(ProceedingJoinPoint pjp,String bizName,<span class="keyword">int</span> times)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(bizName+<span class="string">" "</span>+times);<span class="comment">//执行切入点之前可获取参数值</span></span><br><span class="line">        <span class="comment">//环绕通知</span></span><br><span class="line">        bizName += <span class="string">"???"</span>;<span class="comment">//执行切入点之前 可以修改参数值</span></span><br><span class="line">        times++;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect_aroundInit111"</span>);<span class="comment">//在执行切入点 init 之前执行</span></span><br><span class="line">        Object obj = pjp.proceed();<span class="comment">//执行切入点时，参数值是不会变化</span></span><br><span class="line">        System.out.println(<span class="string">"MyAspect_aroundInit222"</span>);<span class="comment">//在执行切入点 inti 之后执行</span></span><br><span class="line">        System.out.println(bizName+<span class="string">" "</span>+times);<span class="comment">//执行切入点后 参数值才会变化</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建单参数的一个init方法 在AspectBiz类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.schema.advice.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String bizName,<span class="keyword">int</span> times)</span> </span>&#123;<span class="comment">//有参</span></span><br><span class="line">        System.out.println(<span class="string">"AspectBiz_init:"</span>+bizName+<span class="string">" "</span>+times);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="＊Introductions-引入"><a href="#＊Introductions-引入" class="headerlink" title="＊Introductions 引入"></a>＊Introductions 引入</h4><ul><li>在不修改类代码的前提下，为类添加新的方法和属性</li><li>允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象</li><li>由&lt;aop:aspect&gt;中的&lt;aop:declare-parents&gt;元素声明，该元素用于声明所匹配的类型拥有一个新的parent</li></ul><ol><li><p>新建一个接口，和一个实现类（测试：Fit实例getBean 获得AspectBiz的bean实例，执行filter方法即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.schema.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.schema.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FitImpl</span> <span class="keyword">implements</span> <span class="title">Fit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FitImpl_filter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">（所有基于配置文件的aspect只支持singleton模式）</span></span><br><span class="line"><span class="comment"> 1、types-matching 匹配该包下面所有类的方法。</span></span><br><span class="line"><span class="comment"> 2、为它制定了一个新父类（强制类型转换），（即是将Fit转换为AspectBiz的父类）</span></span><br><span class="line"><span class="comment"> 3、implement-interface 明确父类接口，</span></span><br><span class="line"><span class="comment"> 4、default-impl 接口实现方法。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspectAop"</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">"com.soloist.aop.schema.advice.biz.*(+)"</span> <span class="attr">implement-interface</span>=<span class="string">"com.soloist.aop.schema.advice.Fit"</span> <span class="attr">default-impl</span>=<span class="string">"com.soloist.aop.schema.advice.FitImpl"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="＊Spring-AOP-API"><a href="#＊Spring-AOP-API" class="headerlink" title="＊Spring AOP API"></a>＊Spring AOP API</h4><ul><li>API 使 Spring AOP 的基础，直接实现接口，覆盖方法来实现各种的Advice，不是使用xml配置或者是注解.</li></ul><ol><li><p>定义一个接口 Bizlogic，定义一个类 BizlogicImpl实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizlogicImpl</span> <span class="keyword">implements</span> <span class="title">Bizlogic</span></span>&#123;</span><br><span class="line"><span class="comment">//切入点pointcut</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BizlogicImpl:logic save"</span>);       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"logic save"</span>;<span class="comment">//需要传递的信息</span></span><br><span class="line">        <span class="comment">//throw new RuntimeException();//测试throwsAdvice,直接抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Pointcut：自定义pointcut ,mappedNames表示匹配的方法，list作集合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bizlogicImlTarget"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.BizlogicImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcutBean"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcut"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>sa*<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--以sa开头的方法都是切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Before Advice——在切入点之前执行但不能改变返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在切入点之前执行，也在around围绕通知前执行，只能获得类的类类型不能获得传递的参数值</span></span><br><span class="line">        System.out.println(<span class="string">"MoocBeforeAdvice:"</span>+method.getName()+<span class="string">"   "</span>+target.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>After Returning Advice——后置通知必须实现，可以访问返回值但不能修改，可以访问被调用方法、方法的参数和目标。如果抛出异常，将会抛出拦截器，替代返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocAfterReturningAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在around围绕通知方法执行完之后执行，可获得参数传递参数值</span></span><br><span class="line">        System.out.println(<span class="string">"MoocAfterReturningAdvice:"</span>+method.getName()+<span class="string">"  "</span>+target.getClass().getName()+<span class="string">"  "</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AfterThrows Advice——有两个重载方法，根据参数自动匹配。抛出异常后覆盖原有异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.ThrowsAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果连接点抛出异常，throws advice 在接入点返回后被调用，还会覆盖原有的异常</span></span><br><span class="line">    <span class="comment">//实例接口ThrowsAdvice，必须要有afterThrowing方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception ex)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MoocThrowsAdvice_afterThrowing1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为参数的匹配，调用了下面的抛出异常方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target,Exception ex)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MoocThrowsAdvice_afterThrowing2：  "</span>+method.getName()+<span class="string">"  "</span>+target.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Around Advice——Spring的切入点模型使得切入点可以独立与advice重用，以针对不同的advice可以使用相同切入点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.aop.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//相当于around围绕通知，在invocation.proceed()之后可以获得传递参数值。</span></span><br><span class="line">System.out.println(<span class="string">"切入点之前MoocMethodInterceptor:"</span></span><br><span class="line">                           +invocation.getMethod().getName()+<span class="string">"  "</span></span><br><span class="line">+invocation.getStaticPart().getClass().getName());</span><br><span class="line"></span><br><span class="line">Object obj = invocation.proceed();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"切入点之后——MoocMethodInterceptor:"</span>+obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ProxyFactoryBean</p><ul><li>被代理类没有实现任何接口，使用CGLIB代理，否则JDK代理</li><li>通过设置proxyTargetClass为true，可强制使用CGLIB</li><li>使用ProxyFactoryBean或者其他IOC相关类来创建AOP代理的最重要好处时通知和切入点也可以由IOC来管理</li><li>如果目标类实现一个或者多个接口，那么创建代理的类型依赖ProxyFactoryBean的配置</li><li>如果ProxyFactoryBean的proxyInterfaces属性被设置为一个或者多个全限定接口名，基于JDK的代理将被创建</li><li>第一种方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明 类target 和 advice方法 的bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bizlogicImlTarget"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.BizlogicImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moocBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.MoocBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moocAfterReturningAdvice"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.MoocAfterReturningAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moocMethodInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.MoocMethodInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moocThrowsAdvice"</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.MoocThrowsAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一种配置方式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义pointcut ,mappedNames表示匹配的方法，list作集合（当目标target没有在mappedNames的list范围之中，则before方法不会执行）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcutBean"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcut"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>sa*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义Advisor 将 before方法 和 pointcut 的各自绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"defaultAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"moocBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"pointcutBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正在需要实例化的 bean对象，需绑定 target，interceptorNames表示需要应用到目标对象上的通知Bean的名字，做个list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bizLogicImpl"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bizlogicImlTarget"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>defaultAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocAfterReturningAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocMethodInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocThrowsAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试结果（实例bizLogicImpl的bean，调用save方法）</p><ul><li><p>无异常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MoocBeforeAdvice:save   com.soloist.aop.api.BizlogicImpl</span><br><span class="line">切入点之前——MoocMethodInterceptor:save  java.lang.reflect.Method</span><br><span class="line">BizlogicImpl:logic save</span><br><span class="line">切入点之后——MoocMethodInterceptor:logic save</span><br><span class="line">MoocAfterReturningAdvice:save  com.soloist.aop.api.BizlogicImpl  logic save</span><br></pre></td></tr></table></figure></li><li><p>异常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MoocBeforeAdvice:save   com.soloist.aop.api.BizlogicImpl</span><br><span class="line">切入点之前——MoocMethodInterceptor:save  java.lang.reflect.Method</span><br><span class="line">BizlogicImpl:logic save</span><br><span class="line">MoocThrowsAdvice_afterThrowing2：save  com.soloist.aop.api.BizlogicImpl</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ProxyFactoryBean 代理的第二种方式 JDK动态代理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第二种配置方式（JDK动态代理） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- proxyInterfaces绑定目标接口（第一种没有绑定则靠ProxyFactoryBean自己去发现 是否实现口），第二种配置方式没有实现pointcut，直接去执行所有advice方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bizLogicImpl"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.soloist.aop.api.Bizlogic<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">可在内部直接引用bean，不需要ref去引用外部的bean </span></span><br><span class="line"><span class="comment">推荐用内部引用bean，外部引用bean有一个坏处：可以通过id得到bean，但没有经过proxy处理不会执行advice方法）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean class="com.soloist.aop.api.BizlogicImpl"&gt;&lt;/bean&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bizlogicImlTarget"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocBeforeAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocAfterReturningAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocMethodInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocThrowsAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ProxyFactoryBean 代理的第三种方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第三种配置方式（简化proxy定义） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseProxyBear"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bizLogicImpl"</span> <span class="attr">parent</span>=<span class="string">"baseProxyBear"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.soloist.aop.api.Bizlogic<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.soloist.aop.api.BizlogicImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocBeforeAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocAfterReturningAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocMethodInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>moocThrowsAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring学习-之-AOP的基础&quot;&gt;&lt;a href=&quot;#Spring学习-之-AOP的基础&quot; class=&quot;headerlink&quot; title=&quot;Spring学习 之 AOP的基础&quot;&gt;&lt;/a&gt;Spring学习 之 AOP的基础&lt;/h2&gt;&lt;hr&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring学习之注解篇（一）</title>
    <link href="http://yoursite.com/2017/08/22/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/22/spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2017-08-22T08:54:03.000Z</published>
    <updated>2017-08-24T03:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring学习-之-Bean注解"><a href="#Spring学习-之-Bean注解" class="headerlink" title="Spring学习 之 Bean注解"></a>Spring学习 之 Bean注解</h2><hr><h4 id="＊Bean管理的注解"><a href="#＊Bean管理的注解" class="headerlink" title="＊Bean管理的注解"></a>＊Bean管理的注解</h4><ul><li><p>类的自动检测及Bean注册——通过自动检测类并注册Bean到xml配置文件中</p></li><li><p>xml配置—-&lt;context:annotation-config/&gt;</p><ul><li>xml使用context的基本设置<ol><li>在beans引入xmlns：context地址，引入context的xsi:schemaLocation地址（可在左下角Namespaces勾选）</li><li>&lt;context:component-scan base-package=””&gt; &lt;/context:component-scan/&gt; 填入相对应包的名称（扫描整个包下面的所有注解，也可以用过滤器过滤不需要扫描的文件）</li><li>可直接配置代理方式，有三个可选值：no，interfaces，targetClass（默认是no）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.soloist.bean.annotation"</span> <span class="attr">scoped-proxy</span>=<span class="string">"no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>Bean常用注解 （使用 java 定义 bean）</p><ul><li>@Component——一个通用的注解，可用于任何bean<em>（@Repository、@Service、@Service是@Component的子注解）</em></li><li>@Repository——通常用于注解DAO类，即持久层（与数据库连接）</li><li>@Service——通常用于注解Service类，即服务层</li><li>@Controller——通常用于Controller类，即控制层（MVC）</li><li>@Required——适用于bean属性的setter方法（注解在setter上）（不常用）</li><li>@Autowired——适用于成员变量、setter方法、构造器上（常用）<em>（@Autowired(required=false)可避免找不到bean而抛出异常，但在注解构造器时，每个类只能有一个构造器（一个类可有多个重载的构造器）被标记required=true。@Autowired是由Spring BeanPostProcessor处理的，所以不能在自己的BeanPostProcessor或者BeanFactoryPostProcessor类型应用这些注解，这些类型必须通过 xml 或者Spring的@Bean注解加载）</em></li><li>@Qualifier——-可在@Autowired下用于缩小赋值范围（可用于成员变量、函数参数）（在不用注解的情况下，可在 xml 对应 bean 下进行配置也可达到同样效果）</li><li>@Resource——适用于成员变量、只有一个参数的setter方法，所以在目标是构造器或者一个多参数方法时，最好的方式时使用@Qualifier</li></ul></li><li><p>可通过元注解自定义注解</p></li></ul><hr><h4 id="＊如何用注解定义一个bean"><a href="#＊如何用注解定义一个bean" class="headerlink" title="＊如何用注解定义一个bean"></a>＊如何用注解定义一个bean</h4><ol><li>在新建类名称上方调用注解@Component，bean的id名称会自动匹配成类的名称的首字母小写（例如：BeanAnnotation类的bean的id为beanAnnotation）</li><li>可在注解中自定义bean的id------@Component(“beana”)</li><li>@Scope注解表示作用域<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Component("beana")//可自定义id</span></span><br><span class="line"><span class="meta">@Scope</span><span class="comment">//默认是singleton</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BeanAnnotation say:"</span> + word);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="＊-Repository-Service-Autowired实现注入"><a href="#＊-Repository-Service-Autowired实现注入" class="headerlink" title="＊@Repository @Service @Autowired实现注入"></a>＊@Repository @Service @Autowired实现注入</h4><ul><li><p>@Repository 注解DAO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.mooc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String unit)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MoocSave :"</span>+unit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Service 注解Service</p></li><li>@Autowired 注解变量，setter方法，构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.mooc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoocService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Autowired 可注解 变量本身、变量setter函数（设置注入）、赋值该变量的构造函数（构造注入）</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MoocDAO md;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Autowired//设置注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMd</span><span class="params">(MoocDAO md)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.md = md;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Autowired//构造注入（在使用@Autowired，只有一个构造器被标注为request=true，其余为false）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MoocService</span><span class="params">(MoocDAO md)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.md = md;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MdSave</span><span class="params">(String unit)</span></span>&#123;</span><br><span class="line">md.save(unit+<span class="string">" "</span>+unit.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="＊-Autowired更多使用，及-Qualifier与-Order"><a href="#＊-Autowired更多使用，及-Qualifier与-Order" class="headerlink" title="＊@Autowired更多使用，及@Qualifier与@Order"></a>＊@Autowired更多使用，及@Qualifier与@Order</h4><ol><li><p>创建一个接口BeanInterface，两个实现该接口的类BeanImplOne和BeanImplTwo(@Component注解bean，@Order注解list类型顺序优先级)</p><ul><li><p>BeanImplOne</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.multibean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)<span class="comment">//针对list类型顺序优先级，对map（map无序）无效（数字越小优先级越高）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanImplOne</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BeanImplTwo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.multibean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanImplTwo</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>再建立一个用于调用实现了接口类的 BeanInvoker 类（对于map，自动注入bean的id作为key值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.multibean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInvoker</span> </span>&#123;</span><br><span class="line">  <span class="comment">//用注解方式@Autowired，将实现了BeanInterface接口的两个bean对象，直接加入BeanInterface的list和map中</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, BeanInterface&gt; map;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier</span>(<span class="string">"beanImplOne"</span>)<span class="comment">//缩小赋值范围，表明使用beanImplOne的bean</span></span><br><span class="line">  <span class="keyword">private</span> BeanInterface beanInterface;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"---list---"</span>);</span><br><span class="line">    <span class="keyword">if</span>(list != <span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(BeanInterface bean:list) &#123;</span><br><span class="line">      System.out.println(bean.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"List&lt;BeanInterface&gt; list is null!!!!!!!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---map---"</span>);</span><br><span class="line">    <span class="keyword">if</span>(map != <span class="keyword">null</span> &amp;&amp; map.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;String, BeanInterface&gt;entry:map.entrySet()) &#123;</span><br><span class="line">          System.out.println(<span class="string">"Map_Key="</span>+entry.getKey()+<span class="string">"::::"</span>+<span class="string">"Map_Value="</span></span><br><span class="line">                                 +entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Map&lt;String, BeanInterface&gt; map is null!!!!!!!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">if</span>(beanInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"@Qualifier绑定:"</span>beanInterface.getClass().getName());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"beanInterface is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试BeanInvoker的say()结果（自行调用BeanInvoker的bean进行测试）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---list---</span><br><span class="line">com.soloist.bean.annotation.multibean.BeanImplTwo</span><br><span class="line">com.soloist.bean.annotation.multibean.BeanImplOne</span><br><span class="line">---map---</span><br><span class="line">Map_Key=beanImplOne::::Map_Value=com.soloist.bean.annotation.multibean.BeanImplOne@d706f19</span><br><span class="line">Map_Key=beanImplTwo::::Map_Value=com.soloist.bean.annotation.multibean.BeanImplTwo@30b7c004</span><br><span class="line"></span><br><span class="line">@Qualifier绑定:com.soloist.bean.annotation.multibean.BeanImplOne</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="＊基于Java的容器注解"><a href="#＊基于Java的容器注解" class="headerlink" title="＊基于Java的容器注解"></a>＊基于Java的容器注解</h4><ul><li><p>@Bean——标识一个用于配置和初始化一个由SpringIOC容器管理的新对象的方法，类似于 xml 配置文件的 &lt;bean/&gt;。（可以在Spring的@Component注解的类中使用@Bean注解任何方法，但是一般与@Configuration搭配使用）</p><ol><li><p>注解方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line">  <span class="comment">//@Bean(name="service",initMethod="init",destroyMethod="destroy")</span></span><br><span class="line">  <span class="comment">//可以自定义名字或者bean的其他属性（例如：init-method和destroy-method在方法上）</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.soloist.service.MyServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Scope——设置作用域和代理模式</p></li><li><p>@ImportResource——用于引入资源文件的xml配置文件</p></li><li><p>@Value——用于取出资源文件的值，在赋值给变量</p><ol><li><p>创建一个类StoreConfig，用于读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ScopedProxyMode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用@Configuration注释的类相当于xml配置文件</span></span><br><span class="line">    <span class="comment">//@Bean(name="myStore") 相当于配置bean对象，还可以自定义名字（若没有自定义名字，则默认方法名称getStringStore作name）</span></span><br><span class="line">    <span class="comment">//同时@Bean中也可以定义其他属性</span></span><br><span class="line">    <span class="comment">//initMethod的方法或者destroyMethod的方法，其源码在new的对象所属的类 </span></span><br><span class="line">    <span class="comment">//@Scope(value="prototype")</span></span><br><span class="line">    <span class="comment">//设置scope属性(prototype每次请求都是一个新象,proxyMode=ScopedProxyMode.TARGET_CLASS代理模式)</span></span><br><span class="line">    <span class="comment">//@ImportResource("classpath:config.xml")引入资源，在config.xml加载资源文件，再通过注释引入进类中</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;jdbc.url&#125;") 通过Value进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"myStringStore"</span>,initMethod=<span class="string">"init"</span>,destroyMethod=<span class="string">"destory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Store <span class="title">getStringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"myDriverManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDriverManager <span class="title">getMyDriverManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyDriverManager(url,username,password);<span class="comment">//传递取得的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"myStore"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>,proxyMode=ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Store <span class="title">getStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建类MyDriverManager，用于接收数据，数据操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyDriverManager</span><span class="params">(String url,String username,String password)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"url:"</span>+ url);</span><br><span class="line">    System.out.println(<span class="string">"username:"</span>+username);</span><br><span class="line">    System.out.println(<span class="string">"password:"</span>+password);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建类StringStore实现接口Store</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStore</span> <span class="keyword">implements</span> <span class="title">Store</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---storeInit---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---storeDestory---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入的资源文件config.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载资源文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/config.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>没有资源文件，可以手动创建：config.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=127.0.0.1</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure></li><li><p>没有用注解方法，则需要在资源配置文件，给定义的变量绑定值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/config.properties"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.soloist.bean.store.StoreConfig"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h4 id="＊基于泛型的自动装配"><a href="#＊基于泛型的自动装配" class="headerlink" title="＊基于泛型的自动装配"></a>＊基于泛型的自动装配</h4><ul><li><p>创建一个泛型的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.genericity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;T&gt; T表示可以用各种类型进行代替</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个是实现该接口的类</p><ol><li><p>IntegerGenericityImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.genericity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerGenericityImpl</span> <span class="keyword">implements</span> <span class="title">Genericity</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StringGenericityImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.genericity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGenericityImpl</span> <span class="keyword">implements</span> <span class="title">Genericity</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>创建GenericityConfig类，实现注解自动根据泛型注入（但不写@Qualifier(value=”stringGenericity”)缩小范围赋值会报错）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.genericity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value=<span class="string">"stringGenericity"</span>)</span><br><span class="line"><span class="keyword">private</span> Genericity&lt;String&gt; stringG;<span class="comment">//同一个接口类型，注解Autowired会根据具体泛型 自动进行匹配对应的对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value=<span class="string">"integerGenericity"</span>)</span><br><span class="line"><span class="keyword">private</span> Genericity&lt;Integer&gt; integerG;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"stringGenericity"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringGenericityImpl <span class="title">getStringGenericityImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringGenericityImpl();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"integerGenericity"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegerGenericityImpl <span class="title">getIntegerGenericityImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IntegerGenericityImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"myGenericity"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Genericity <span class="title">StringGenericityImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"stringG:"</span>+stringG.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"integerG:"</span>+integerG.getClass().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringGenericityImpl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Spring对JSR的支持：-PostConstruct和-PreDestroy"><a href="#Spring对JSR的支持：-PostConstruct和-PreDestroy" class="headerlink" title="Spring对JSR的支持：@PostConstruct和@PreDestroy"></a>Spring对JSR的支持：@PostConstruct和@PreDestroy</h4><ul><li><p>创建一个类JsrDAO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.jsr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span><span class="comment">//将JsrDAO声明为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"JsrDAO_save"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个类JsrService（@Resource——适用于成员变量、只有一个参数的setter方法）</p><ul><li>使用@Named和@Inject需要引入inject包</li><li>@Inject等效于@Autowired，可用于类、属性、方法、构造器</li><li>如果想使用特定名称进行依赖注入，可使用@Named（@Named与@Component等效）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soloist.bean.annotation.jsr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Service//两种注解方式</span></span><br><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrService</span> </span>&#123;</span><br><span class="line"><span class="comment">//@Resource//注入jsrDAO的bean实例（在setter方法也行）</span></span><br><span class="line"><span class="comment">//@Inject</span></span><br><span class="line"><span class="keyword">private</span> JsrDAO jsrDAO;</span><br><span class="line"><span class="comment">//@Resource</span></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJsrDAO</span><span class="params">(@Named(<span class="string">"jsrDAO"</span>)</span>JsrDAO jsrDAO) </span>&#123;<span class="comment">//@Named("jsrDAO")在对一个接口有多种泛型时，可用于区别</span></span><br><span class="line"><span class="keyword">this</span>.jsrDAO = jsrDAO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span><span class="comment">//等于给bean中initMethod="init"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"JsrService_init"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span><span class="comment">//等于给bean中destroyMethod="destroy"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"JsrService_destroy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">jsrDAO.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring学习-之-Bean注解&quot;&gt;&lt;a href=&quot;#Spring学习-之-Bean注解&quot; class=&quot;headerlink&quot; title=&quot;Spring学习 之 Bean注解&quot;&gt;&lt;/a&gt;Spring学习 之 Bean注解&lt;/h2&gt;&lt;hr&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
